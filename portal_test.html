<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POLYMIR - Portal Test Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ffff;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
            z-index: 100;
        }
        .key {
            color: #ffff00;
            font-weight: bold;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        .status {
            margin: 5px 0;
        }
        .portal-active {
            color: #ff00ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>

    <div id="ui">
        <div class="status">Mode: <span id="mode">WAND</span></div>
        <div class="status">Block: <span id="block-type">STONE</span></div>
        <div class="status">Portal Blocks: <span id="portal-count">0</span></div>
        <div class="status">Active Portals: <span id="active-portals">0</span></div>
        <div class="status">FPS: <span id="fps">60</span></div>
        <div class="status">Position: <span id="position">0, 0, 0</span></div>
    </div>

    <div id="controls">
        <h3 style="margin-top: 0; color: #00ffff;">PORTAL TEST CONTROLS</h3>
        <div><span class="key">WASD</span> - Move</div>
        <div><span class="key">SPACE</span> - Up</div>
        <div><span class="key">SHIFT</span> - Down</div>
        <div><span class="key">Mouse</span> - Look around</div>
        <div><span class="key">LEFT CLICK</span> - Place block</div>
        <div><span class="key">RIGHT CLICK</span> - Remove block</div>
        <div><span class="key">1-5</span> - Select block type</div>
        <div style="margin-top: 10px;">
            <div><span class="key">1</span> - Stone</div>
            <div><span class="key">2</span> - Grass</div>
            <div><span class="key">3</span> - Dirt</div>
            <div><span class="key">4</span> - Portal Block (Cyan)</div>
            <div><span class="key">5</span> - Glass</div>
        </div>
        <div style="margin-top: 10px; color: #ff00ff; font-size: 11px;">
            <div>Portal blocks auto-link when you place a 2nd portal structure!</div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="module">
        import * as THREE from './src/lib/three.module.js';
        import { Chunk } from './src/spatial/Chunk.js';
        import { ChunkCoordinate } from './src/spatial/ChunkCoordinate.js';
        import { VOXEL_TYPES } from './src/data/voxel/VoxelTypes.js';
        import { PortalManager } from './src/world/PortalManager.js';
        import { MeshFactory } from './src/rendering/MeshFactory.js';
        import { FPSControls } from './src/controls/FPSControls.js';

        class PortalTestScene {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true
                });

                this.chunkSize = 16;
                this.chunks = new Map();
                this.chunkMeshes = new Map();

                // Use engine's PortalManager properly
                this.portalManager = new PortalManager(this.scene, this.renderer, this);

                this.currentBlockType = VOXEL_TYPES.STONE.id;
                this.raycaster = new THREE.Raycaster();
                this.raycaster.far = 100;

                this.lastTime = performance.now();
                this.frameCount = 0;

                this.setupRenderer();
                this.setupLighting();
                this.setupControls();
                this.createWorld();
                this.animate();
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

                this.camera.position.set(0, 5, 10);
                this.camera.rotation.order = 'YXZ';

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLighting() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);

                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(50, 100, 50);
                this.scene.add(sun);
            }

            // Implement chunk manager interface for PortalManager
            getChunk(chunkX, chunkY, chunkZ) {
                const key = ChunkCoordinate.toKey(chunkX, chunkY, chunkZ);
                return this.chunks.get(key);
            }

            setupControls() {
                // Use engine's FPSControls
                this.fpsControls = new FPSControls(this.camera, this.canvas);
                this.keys = {};

                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;

                    // Block type selection
                    if (e.key >= '1' && e.key <= '5') {
                        const types = [
                            VOXEL_TYPES.STONE.id,
                            VOXEL_TYPES.GRASS.id,
                            VOXEL_TYPES.DIRT.id,
                            VOXEL_TYPES.PORTAL_BLOCK.id,
                            VOXEL_TYPES.GLASS.id
                        ];
                        this.currentBlockType = types[parseInt(e.key) - 1];
                        this.updateUI();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Override FPSControls mouse handlers for building
                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.fpsControls.isLocked) return;

                    if (e.button === 0) {
                        this.placeBlock();
                    } else if (e.button === 2) {
                        this.removeBlock();
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            createWorld() {
                for (let cx = -2; cx <= 2; cx++) {
                    for (let cy = -1; cy <= 1; cy++) {
                        for (let cz = -2; cz <= 2; cz++) {
                            this.generateChunk(cx, cy, cz);
                        }
                    }
                }
            }

            generateChunk(cx, cy, cz) {
                const chunk = new Chunk(cx, cy, cz, this.chunkSize);

                // Simple flat platform generation
                for (let x = 0; x < this.chunkSize; x++) {
                    for (let z = 0; z < this.chunkSize; z++) {
                        for (let y = 0; y < this.chunkSize; y++) {
                            const worldY = cy * this.chunkSize + y;

                            if (worldY < 0) {
                                const blockType = worldY < -5 ? VOXEL_TYPES.STONE.id : VOXEL_TYPES.DIRT.id;
                                const blockColor = worldY < -5 ? VOXEL_TYPES.STONE.color : VOXEL_TYPES.DIRT.color;
                                chunk.setVoxel(x, y, z, {
                                    type: blockType,
                                    color: blockColor
                                });
                            } else if (worldY === 0) {
                                chunk.setVoxel(x, y, z, {
                                    type: VOXEL_TYPES.GRASS.id,
                                    color: VOXEL_TYPES.GRASS.color
                                });
                            }
                        }
                    }
                }

                const key = ChunkCoordinate.toKey(cx, cy, cz);
                this.chunks.set(key, chunk);
                this.rebuildChunkMesh(cx, cy, cz);
            }

            rebuildChunkMesh(cx, cy, cz) {
                const key = ChunkCoordinate.toKey(cx, cy, cz);
                const chunk = this.chunks.get(key);
                if (!chunk) return;

                const oldMesh = this.chunkMeshes.get(key);
                if (oldMesh) {
                    this.scene.remove(oldMesh);
                    MeshFactory.disposeMesh(oldMesh);
                }

                const geometryData = chunk.buildMesh((chunkX, chunkY, chunkZ, localX, localY, localZ) => {
                    return this.neighborLookup(chunkX, chunkY, chunkZ, localX, localY, localZ);
                });

                if (geometryData && geometryData.positions.length > 0) {
                    const material = new THREE.MeshLambertMaterial({ vertexColors: true });
                    const mesh = MeshFactory.createChunkMesh(geometryData, material);
                    this.scene.add(mesh);
                    this.chunkMeshes.set(key, mesh);
                }
            }

            neighborLookup(chunkX, chunkY, chunkZ, localX, localY, localZ) {
                const neighborChunkX = chunkX + (localX < 0 ? -1 : (localX >= this.chunkSize ? 1 : 0));
                const neighborChunkY = chunkY + (localY < 0 ? -1 : (localY >= this.chunkSize ? 1 : 0));
                const neighborChunkZ = chunkZ + (localZ < 0 ? -1 : (localZ >= this.chunkSize ? 1 : 0));

                const neighborKey = ChunkCoordinate.toKey(neighborChunkX, neighborChunkY, neighborChunkZ);
                const neighborChunk = this.chunks.get(neighborKey);

                if (!neighborChunk) return false;

                const nx = ((localX % this.chunkSize) + this.chunkSize) % this.chunkSize;
                const ny = ((localY % this.chunkSize) + this.chunkSize) % this.chunkSize;
                const nz = ((localZ % this.chunkSize) + this.chunkSize) % this.chunkSize;

                return neighborChunk.hasVoxel(nx, ny, nz);
            }

            raycast() {
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);

                this.raycaster.set(this.camera.position, direction);

                const meshes = Array.from(this.chunkMeshes.values());
                const intersects = this.raycaster.intersectObjects(meshes);

                return intersects.length > 0 ? intersects[0] : null;
            }

            placeBlock() {
                const hit = this.raycast();
                if (!hit || !hit.face) return;

                const position = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
                const blockPos = {
                    x: Math.floor(position.x),
                    y: Math.floor(position.y),
                    z: Math.floor(position.z)
                };

                const chunkPos = {
                    cx: Math.floor(blockPos.x / this.chunkSize),
                    cy: Math.floor(blockPos.y / this.chunkSize),
                    cz: Math.floor(blockPos.z / this.chunkSize)
                };

                const localPos = {
                    x: ((blockPos.x % this.chunkSize) + this.chunkSize) % this.chunkSize,
                    y: ((blockPos.y % this.chunkSize) + this.chunkSize) % this.chunkSize,
                    z: ((blockPos.z % this.chunkSize) + this.chunkSize) % this.chunkSize
                };

                const key = ChunkCoordinate.toKey(chunkPos.cx, chunkPos.cy, chunkPos.cz);
                const chunk = this.chunks.get(key);

                if (chunk) {
                    const voxelType = Object.values(VOXEL_TYPES).find(t => t.id === this.currentBlockType);
                    chunk.setVoxel(localPos.x, localPos.y, localPos.z, {
                        type: this.currentBlockType,
                        color: voxelType.color
                    });

                    // Use PortalManager for portal block placement
                    if (this.currentBlockType === VOXEL_TYPES.PORTAL_BLOCK.id) {
                        const placementNormal = {
                            x: hit.face.normal.x,
                            y: hit.face.normal.y,
                            z: hit.face.normal.z
                        };
                        const placementRotation = {
                            yaw: this.camera.rotation.y,
                            pitch: this.camera.rotation.x
                        };
                        this.portalManager.onPortalBlockPlaced(
                            blockPos.x, blockPos.y, blockPos.z,
                            placementNormal,
                            placementRotation
                        );
                    }

                    this.rebuildChunkMesh(chunkPos.cx, chunkPos.cy, chunkPos.cz);
                    this.rebuildAdjacentChunks(chunkPos.cx, chunkPos.cy, chunkPos.cz, localPos);
                    this.updateUI();
                }
            }

            removeBlock() {
                const hit = this.raycast();
                if (!hit || !hit.face) return;

                const position = hit.point.clone().sub(hit.face.normal.clone().multiplyScalar(0.5));
                const blockPos = {
                    x: Math.floor(position.x),
                    y: Math.floor(position.y),
                    z: Math.floor(position.z)
                };

                const chunkPos = {
                    cx: Math.floor(blockPos.x / this.chunkSize),
                    cy: Math.floor(blockPos.y / this.chunkSize),
                    cz: Math.floor(blockPos.z / this.chunkSize)
                };

                const localPos = {
                    x: ((blockPos.x % this.chunkSize) + this.chunkSize) % this.chunkSize,
                    y: ((blockPos.y % this.chunkSize) + this.chunkSize) % this.chunkSize,
                    z: ((blockPos.z % this.chunkSize) + this.chunkSize) % this.chunkSize
                };

                const key = ChunkCoordinate.toKey(chunkPos.cx, chunkPos.cy, chunkPos.cz);
                const chunk = this.chunks.get(key);

                if (chunk) {
                    // Check if this is a portal block before removing
                    const voxel = chunk.getVoxel(localPos.x, localPos.y, localPos.z);
                    const wasPortalBlock = voxel && voxel.type === VOXEL_TYPES.PORTAL_BLOCK.id;

                    chunk.removeVoxel(localPos.x, localPos.y, localPos.z);

                    // Use PortalManager for portal block removal
                    if (wasPortalBlock) {
                        this.portalManager.onPortalBlockRemoved(blockPos.x, blockPos.y, blockPos.z);
                    }

                    this.rebuildChunkMesh(chunkPos.cx, chunkPos.cy, chunkPos.cz);
                    this.rebuildAdjacentChunks(chunkPos.cx, chunkPos.cy, chunkPos.cz, localPos);
                    this.updateUI();
                }
            }

            rebuildAdjacentChunks(cx, cy, cz, localPos) {
                if (localPos.x === 0) this.rebuildChunkMesh(cx - 1, cy, cz);
                if (localPos.x === this.chunkSize - 1) this.rebuildChunkMesh(cx + 1, cy, cz);
                if (localPos.y === 0) this.rebuildChunkMesh(cx, cy - 1, cz);
                if (localPos.y === this.chunkSize - 1) this.rebuildChunkMesh(cx, cy + 1, cz);
                if (localPos.z === 0) this.rebuildChunkMesh(cx, cy, cz - 1);
                if (localPos.z === this.chunkSize - 1) this.rebuildChunkMesh(cx, cy, cz + 1);
            }

            update(deltaTime) {
                // Use engine's FPSControls for movement
                this.fpsControls.update(deltaTime);

                // Apply collision with voxels
                this.applyCollision();
            }

            applyCollision() {
                const playerHeight = 1.7;
                const rayOrigin = this.camera.position.clone();
                rayOrigin.y -= playerHeight / 2;

                // Check downward for ground
                const down = new THREE.Vector3(0, -1, 0);
                this.raycaster.set(rayOrigin, down);
                this.raycaster.far = 2;

                const meshes = Array.from(this.chunkMeshes.values());
                const downIntersects = this.raycaster.intersectObjects(meshes);

                if (downIntersects.length > 0) {
                    const groundDist = downIntersects[0].distance;
                    if (groundDist < playerHeight / 2 + 0.1) {
                        this.camera.position.y = downIntersects[0].point.y + playerHeight;
                    }
                }
            }

            updateUI() {
                const typeName = Object.values(VOXEL_TYPES).find(t => t.id === this.currentBlockType)?.name || 'Unknown';
                document.getElementById('block-type').textContent = typeName;

                // Count portal blocks and linked portals from PortalManager
                const linkedCount = this.portalManager.voxelPortals.filter(p => p.linkedTo !== null).length / 2;
                const unlinkedCount = this.portalManager.voxelPortals.filter(p => p.linkedTo === null).length;

                document.getElementById('portal-count').textContent = this.portalManager.voxelPortals.length;
                document.getElementById('active-portals').textContent = `${linkedCount} linked, ${unlinkedCount} unlinked`;
                document.getElementById('position').textContent =
                    `${Math.floor(this.camera.position.x)}, ${Math.floor(this.camera.position.y)}, ${Math.floor(this.camera.position.z)}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) * 0.001;
                this.lastTime = currentTime;

                this.frameCount++;
                if (this.frameCount % 60 === 0) {
                    document.getElementById('fps').textContent = Math.round(1 / deltaTime);
                }

                this.update(deltaTime);
                this.updateUI();

                // Update portal views before rendering
                this.portalManager.updatePortalViews(this.camera);

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            const scene = new PortalTestScene();
            window.testScene = scene;
            console.log('ðŸŒ€ Portal test scene initialized');
            console.log('ðŸ“‹ Controls:');
            console.log('  - Click to lock mouse');
            console.log('  - WASD to move, SPACE/SHIFT for up/down');
            console.log('  - Left click to place blocks');
            console.log('  - Right click to remove blocks');
            console.log('  - Keys 1-5 to select block type');
            console.log('  - 4 = Portal blocks (cyan) - auto-links when 2nd portal placed');
            console.log('Use window.testScene to inspect scene');
        });
    </script>
</body>
</html>
