<!DOCTYPE html>
<html>
<head>
    <title>Planet Voxel Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        FPS: <span id="fps">0</span> | Memory: <span id="memory">0</span> MB<br>
        Scroll to zoom, drag to rotate<br>
        <span id="mode">Rendering: MESH</span><br>
        Distance: <span id="distance">0</span>m<br>
        LOD switches at 300m
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Simple test: Planet that switches between mesh and voxel rendering

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(100, 100, 100);
        scene.add(sun);

        // Planet parameters
        const planetRadius = 150;
        const voxelSize = 1; // Each voxel is 1m (matching the planet shader scale)

        // Build/structure references placed on planet
        const planetBuildReferences = new Map(); // 'buildId' -> { mvox_id, position, rotation, scale_ratio }
        const loadedBuilds = new Map(); // 'buildId' -> VoxelChunk (loaded build meshes)

        // ===== SHADER SAMPLING FUNCTIONS =====
        // These EXACTLY match the planet vertex/fragment shaders
        // CRITICAL: Hash function must produce identical output to GLSL version

        // Hash function MUST match GLSL shader exactly
        function hash(x, y, z) {
            let p = { x: x * 443.897, y: y * 441.423, z: z * 437.195 };
            // fract(p)
            p.x = p.x - Math.floor(p.x);
            p.y = p.y - Math.floor(p.y);
            p.z = p.z - Math.floor(p.z);

            // p += dot(p, p.yxz + 19.19)
            // dot(p, p.yxz + 19.19) = p.x*(p.y+19.19) + p.y*(p.x+19.19) + p.z*(p.z+19.19)
            const dotProduct = p.x * (p.y + 19.19) + p.y * (p.x + 19.19) + p.z * (p.z + 19.19);
            p.x += dotProduct;
            p.y += dotProduct;
            p.z += dotProduct;

            // return fract((p.x + p.y) * p.z)
            const result = (p.x + p.y) * p.z;
            return result - Math.floor(result);
        }

        function noise3d(x, y, z) {
            const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
            const fx = x - ix, fy = y - iy, fz = z - iz;
            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);
            const sz = fz * fz * (3 - 2 * fz);

            const c000 = hash(ix, iy, iz);
            const c100 = hash(ix + 1, iy, iz);
            const c010 = hash(ix, iy + 1, iz);
            const c110 = hash(ix + 1, iy + 1, iz);
            const c001 = hash(ix, iy, iz + 1);
            const c101 = hash(ix + 1, iy, iz + 1);
            const c011 = hash(ix, iy + 1, iz + 1);
            const c111 = hash(ix + 1, iy + 1, iz + 1);

            const k0 = c000 + (c100 - c000) * sx;
            const k1 = c010 + (c110 - c010) * sx;
            const k2 = c001 + (c101 - c001) * sx;
            const k3 = c011 + (c111 - c011) * sx;
            const k4 = k0 + (k1 - k0) * sy;
            const k5 = k2 + (k3 - k2) * sy;

            return k4 + (k5 - k4) * sz;
        }

        // Sample height at a sphere position (EXACTLY matches vertex shader)
        function getHeightAtSpherePos(sphereX, sphereY, sphereZ) {
            let height = 0;
            height += (noise3d(sphereX * 2, sphereY * 2, sphereZ * 2) - 0.5) * 15;
            height += (noise3d(sphereX * 5, sphereY * 5, sphereZ * 5) - 0.5) * 8;
            height += (noise3d(sphereX * 12, sphereY * 12, sphereZ * 12) - 0.5) * 4;
            height += (noise3d(sphereX * 25, sphereY * 25, sphereZ * 25) - 0.5) * 2;
            return height * 0.5; // 0.5 scale factor from shader
        }

        // Get terrain color (EXACTLY matches fragment shader)
        function getTerrainColor(height, sphereX, sphereY, sphereZ) {
            if (height < -5) return 0x2269B0; // Deep ocean
            if (height < 0) return 0x4D96C7;   // Shallow water
            if (height < 2) return 0xC2B380;   // Beach
            if (height < 10) return 0x4D9A4D;  // Grassland
            if (height < 18) return 0x3D833D;  // Forest
            if (height < 25) return 0x786358;  // Mountains
            return 0xF0F0FA;                   // Snow
        }

        // ===== PLANET DATA LOADING (.mvox) =====
        // Load from server/cache if exists, otherwise generate
        const CHUNK_SIZE = 16;
        const planetChunks = new Map(); // 'cx,cy,cz' -> { voxels: Map, buildRefs: [] }
        const buildMvoxCache = new Map(); // 'mvox_id' -> { voxels: Map } (cached build data)

        function chunkKey(cx, cy, cz) {
            return `${cx},${cy},${cz}`;
        }

        // Try to fetch .mvox chunk from server/IndexedDB
        async function fetchMvoxChunk(cx, cy, cz) {
            const key = chunkKey(cx, cy, cz);

            // Try IndexedDB cache first (instant load)
            try {
                const cached = await loadFromIndexedDB(`planet_chunk_${key}`);
                if (cached) {
                    console.log(`Loaded chunk ${key} from cache`);
                    return cached;
                }
            } catch (e) {
                // Cache miss, continue
            }

            // Try fetch from server (simulate with /mvox endpoint)
            try {
                const response = await fetch(`/mvox/planet_earth_${key}.mvox`);
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const chunkData = decodeMvoxChunk(arrayBuffer);
                    // Cache for next time
                    await saveToIndexedDB(`planet_chunk_${key}`, chunkData);
                    console.log(`Loaded chunk ${key} from server`);
                    return chunkData;
                }
            } catch (e) {
                // Server doesn't have it, will generate
            }

            // Fallback: Generate chunk procedurally
            return generateChunkProcedurally(cx, cy, cz);
        }

        // Generate a single chunk procedurally (fallback)
        function generateChunkProcedurally(cx, cy, cz) {
            const chunkWorldX = cx * CHUNK_SIZE;
            const chunkWorldY = cy * CHUNK_SIZE;
            const chunkWorldZ = cz * CHUNK_SIZE;

            const chunkDist = Math.sqrt(chunkWorldX * chunkWorldX +
                                       chunkWorldY * chunkWorldY +
                                       chunkWorldZ * chunkWorldZ);

            if (chunkDist > planetRadius + 50) return null;

            const chunk = { voxels: new Map(), buildRefs: [] };
            let chunkVoxelCount = 0;

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let y = 0; y < CHUNK_SIZE; y++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = chunkWorldX + x;
                        const worldY = chunkWorldY + y;
                        const worldZ = chunkWorldZ + z;

                        const dist = Math.sqrt(worldX * worldX + worldY * worldY + worldZ * worldZ);

                        const sphereX = worldX / dist;
                        const sphereY = worldY / dist;
                        const sphereZ = worldZ / dist;

                        const height = getHeightAtSpherePos(sphereX, sphereY, sphereZ);
                        const surfaceRadius = planetRadius + height;

                        if (dist <= surfaceRadius) {
                            const color = getTerrainColor(height, sphereX, sphereY, sphereZ);
                            chunk.voxels.set(`${x},${y},${z}`, { color });
                            chunkVoxelCount++;
                        }
                    }
                }
            }

            // TODO: Check planet metadata for build references in this chunk's region
            // Format: { buildId, mvox_id, position, rotation, scale_ratio }

            return chunkVoxelCount > 0 ? chunk : null;
        }

        // Fetch build .mvox file from server/cache
        async function fetchBuildMvox(mvox_id) {
            if (buildMvoxCache.has(mvox_id)) {
                return buildMvoxCache.get(mvox_id);
            }

            // Try fetch from server
            try {
                const response = await fetch(`/mvox/${mvox_id}.mvox`);
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const buildData = decodeMvoxChunk(arrayBuffer);
                    buildMvoxCache.set(mvox_id, buildData);
                    return buildData;
                }
            } catch (e) {
                console.warn(`Failed to fetch build ${mvox_id}:`, e);
            }

            return null;
        }

        // IndexedDB helpers
        let db;
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PolymirVoxelCache', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('chunks')) {
                        db.createObjectStore('chunks');
                    }
                };
            });
        }

        async function loadFromIndexedDB(key) {
            if (!db) await initIndexedDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('chunks', 'readonly');
                const store = tx.objectStore('chunks');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveToIndexedDB(key, data) {
            if (!db) await initIndexedDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('chunks', 'readwrite');
                const store = tx.objectStore('chunks');
                const request = store.put(data, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Decode .mvox binary format (simplified - real format includes NBT)
        function decodeMvoxChunk(arrayBuffer) {
            // TODO: Implement proper .mvox decoding
            // For now, assume it's JSON-encoded voxel data
            const decoder = new TextDecoder();
            const json = decoder.decode(arrayBuffer);
            return JSON.parse(json);
        }

        // Pre-generate planet data ASYNCHRONOUSLY but complete before render
        async function initializePlanetData() {
            console.log('Initializing planet voxel data (async)...');

            const chunkRadius = Math.ceil((planetRadius + 30) / CHUNK_SIZE);
            const batchSize = 10;
            let count = 0;

            for (let cx = -chunkRadius; cx <= chunkRadius; cx++) {
                for (let cy = -chunkRadius; cy <= chunkRadius; cy++) {
                    for (let cz = -chunkRadius; cz <= chunkRadius; cz++) {
                        const key = chunkKey(cx, cy, cz);
                        const chunk = generateChunkProcedurally(cx, cy, cz);
                        if (chunk) {
                            planetChunks.set(key, chunk);
                        }

                        // Yield to main thread every N chunks
                        count++;
                        if (count % batchSize === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                }
            }

            console.log(`Planet initialized: ${planetChunks.size} chunks ready`);
        }

        // Create planet MESH (for far view) with custom shader to cull loaded chunks
        const planetGeo = new THREE.IcosahedronGeometry(planetRadius, 5);

        // Custom shader material that culls fragments inside loaded chunks
        // Use a 3D texture to track loaded chunks (much more efficient than array)
        // Each voxel in texture represents a chunk position in world space
        const CHUNK_TEXTURE_SIZE = 64; // 64³ = 262,144 possible chunk positions
        const chunkTextureData = new Uint8Array(CHUNK_TEXTURE_SIZE * CHUNK_TEXTURE_SIZE * CHUNK_TEXTURE_SIZE);
        const chunkTexture = new THREE.DataTexture3D(chunkTextureData, CHUNK_TEXTURE_SIZE, CHUNK_TEXTURE_SIZE, CHUNK_TEXTURE_SIZE);
        chunkTexture.format = THREE.RedFormat;
        chunkTexture.type = THREE.UnsignedByteType;
        chunkTexture.minFilter = THREE.NearestFilter;
        chunkTexture.magFilter = THREE.NearestFilter;
        chunkTexture.needsUpdate = true;

        const planetMat = new THREE.ShaderMaterial({
            uniforms: {
                chunkTexture: { value: chunkTexture },
                chunkTextureSize: { value: CHUNK_TEXTURE_SIZE },
                chunkSize: { value: CHUNK_SIZE },
                lightPosition: { value: new THREE.Vector3(100, 100, 100) },
                ambientIntensity: { value: 0.4 },
                planetRadius: { value: planetRadius },
                debugCulling: { value: 0.0 } // 0 = normal, 1 = show culled areas in red
            },
            vertexShader: `
                uniform float planetRadius;
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec3 vSpherePos;
                varying float vHeight;

                // Hash-based noise for vertex shader
                float hash(vec3 p) {
                    p = fract(p * vec3(443.897, 441.423, 437.195));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }

                float noise3d(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);

                    return mix(
                        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }

                void main() {
                    vec3 spherePos = normalize(position);
                    vSpherePos = spherePos;

                    // Multi-octave 3D noise directly on sphere surface
                    float height = 0.0;
                    height += (noise3d(spherePos * 2.0) - 0.5) * 15.0;      // Continents
                    height += (noise3d(spherePos * 5.0) - 0.5) * 8.0;       // Mountain ranges
                    height += (noise3d(spherePos * 12.0) - 0.5) * 4.0;      // Hills
                    height += (noise3d(spherePos * 25.0) - 0.5) * 2.0;      // Detail

                    vHeight = height;

                    // Displace along sphere normal
                    vec3 displaced = position + spherePos * height * 0.5;
                    vPosition = displaced;
                    vNormal = normalize(normalMatrix * spherePos);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                }
            `,
            fragmentShader: `
                precision highp sampler3D;

                uniform sampler3D chunkTexture;
                uniform float chunkTextureSize;
                uniform float chunkSize;
                uniform vec3 lightPosition;
                uniform float ambientIntensity;
                uniform float debugCulling;
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec3 vSpherePos;
                varying float vHeight;

                // Hash for noise
                float hash(vec3 p) {
                    p = fract(p * vec3(443.897, 441.423, 437.195));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }

                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(
                        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }

                vec3 getTerrainColor(float height, vec3 spherePos) {
                    vec3 color;

                    if (height < -5.0) {
                        // Deep ocean
                        color = vec3(0.13, 0.43, 0.69);
                    } else if (height < 0.0) {
                        // Shallow water
                        color = mix(vec3(0.13, 0.43, 0.69), vec3(0.30, 0.59, 0.78), (height + 5.0) / 5.0);
                    } else if (height < 2.0) {
                        // Beach/shore
                        color = vec3(0.76, 0.70, 0.50);
                    } else if (height < 10.0) {
                        // Grassland with variation
                        float variation = noise(spherePos * 40.0) * 0.1;
                        color = vec3(0.30, 0.60, 0.30) + vec3(variation);
                    } else if (height < 18.0) {
                        // Forest/hills with darker green
                        float variation = noise(spherePos * 60.0) * 0.08;
                        color = vec3(0.24, 0.51, 0.24) + vec3(variation);
                    } else if (height < 25.0) {
                        // Mountains - rocky brown/gray
                        float rockiness = noise(spherePos * 80.0);
                        color = mix(vec3(0.47, 0.39, 0.35), vec3(0.55, 0.55, 0.50), rockiness);
                    } else {
                        // Snow peaks
                        float snowVariation = noise(spherePos * 100.0) * 0.05;
                        color = vec3(0.94, 0.94, 0.98) + vec3(snowVariation);
                    }

                    return color;
                }

                void main() {
                    // Calculate which chunk this fragment belongs to
                    vec3 chunkCoord = floor(vPosition / chunkSize);

                    // Convert chunk coordinate to texture coordinate (normalized 0-1)
                    // Offset by half texture size to handle negative coordinates
                    vec3 texCoord = (chunkCoord + vec3(chunkTextureSize * 0.5)) / chunkTextureSize;

                    // Sample the 3D texture to check if this chunk is loaded
                    float isLoaded = texture(chunkTexture, texCoord).r;
                    bool shouldCull = isLoaded > 0.5;

                    // Debug mode: show culled areas in red instead of discarding
                    if (debugCulling > 0.5) {
                        if (shouldCull) {
                            gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5); // Red = culled area
                            return;
                        }
                    } else {
                        // Normal mode: discard fragments in loaded chunks
                        if (shouldCull) {
                            discard;
                        }
                    }

                    // Terrain color based on height with noise variation
                    vec3 color = getTerrainColor(vHeight, vSpherePos);

                    // Lighting
                    vec3 lightDir = normalize(lightPosition - vPosition);
                    float diffuse = max(dot(vNormal, lightDir), 0.0);
                    vec3 finalColor = color * (ambientIntensity + diffuse * 0.6);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        const planetMesh = new THREE.Mesh(planetGeo, planetMat);
        scene.add(planetMesh);

        // ===== SHARED RESOURCES (reuse across all chunks) =====
        const SHARED_VOXEL_GEOMETRY = new THREE.BoxGeometry(1, 1, 1);

        // Custom shader material for voxels with proper lighting
        const SHARED_VOXEL_MATERIAL = new THREE.ShaderMaterial({
            uniforms: {
                lightPosition: { value: new THREE.Vector3(100, 100, 100) },
                ambientIntensity: { value: 0.4 }
            },
            vertexShader: `
                attribute vec3 instanceColor;
                varying vec3 vColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vColor = instanceColor;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPos = modelMatrix * instanceMatrix * vec4(position, 1.0);
                    vPosition = worldPos.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 lightPosition;
                uniform float ambientIntensity;
                varying vec3 vColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    // Lighting calculation (same as planet mesh)
                    vec3 lightDir = normalize(lightPosition - vPosition);
                    float diffuse = max(dot(vNormal, lightDir), 0.0);
                    vec3 finalColor = vColor * (ambientIntensity + diffuse * 0.6);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        // ===== GREEDY MESHING =====
        // Combines adjacent same-color exposed faces into larger quads
        // Operates on each face direction independently
        function greedyMeshFaces(exposedFaces) {
            const mergedQuads = [];

            // Group faces by direction
            const facesByDir = {
                'px': [], 'nx': [],
                'py': [], 'ny': [],
                'pz': [], 'nz': []
            };

            for (const face of exposedFaces) {
                facesByDir[face.dir].push(face);
            }

            // Greedy mesh each direction separately
            for (const dir in facesByDir) {
                const faces = facesByDir[dir];
                const visited = new Set();

                // Sort faces by position for consistent meshing
                faces.sort((a, b) => {
                    if (a.z !== b.z) return a.z - b.z;
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });

                for (const face of faces) {
                    const key = `${face.x},${face.y},${face.z}`;
                    if (visited.has(key)) continue;

                    let width = 1, height = 1;

                    // Determine growth axes based on face direction
                    // width grows along axis1, height grows along axis2
                    let axis1, axis2;
                    if (dir === 'px' || dir === 'nx') {
                        axis1 = 'z'; axis2 = 'y'; // width=Z, height=Y
                    } else if (dir === 'py' || dir === 'ny') {
                        axis1 = 'z'; axis2 = 'x'; // width=Z, height=X
                    } else {
                        axis1 = 'x'; axis2 = 'y'; // width=X, height=Y
                    }

                    // Expand in axis1 direction
                    while (true) {
                        const nextFace = faces.find(f =>
                            f[axis1] === face[axis1] + width &&
                            f[axis2] === face[axis2] &&
                            f[getThirdAxis(axis1, axis2)] === face[getThirdAxis(axis1, axis2)] &&
                            f.color === face.color &&
                            !visited.has(`${f.x},${f.y},${f.z}`)
                        );
                        if (!nextFace) break;
                        width++;
                    }

                    // Expand in axis2 direction
                    outerLoop: while (true) {
                        for (let i = 0; i < width; i++) {
                            const testPos = {};
                            testPos[axis1] = face[axis1] + i;
                            testPos[axis2] = face[axis2] + height;
                            testPos[getThirdAxis(axis1, axis2)] = face[getThirdAxis(axis1, axis2)];

                            const nextFace = faces.find(f =>
                                f.x === testPos.x &&
                                f.y === testPos.y &&
                                f.z === testPos.z &&
                                f.color === face.color &&
                                !visited.has(`${f.x},${f.y},${f.z}`)
                            );
                            if (!nextFace) break outerLoop;
                        }
                        height++;
                    }

                    // Mark all merged faces as visited
                    for (let h = 0; h < height; h++) {
                        for (let w = 0; w < width; w++) {
                            const pos = {};
                            pos[axis1] = face[axis1] + w;
                            pos[axis2] = face[axis2] + h;
                            pos[getThirdAxis(axis1, axis2)] = face[getThirdAxis(axis1, axis2)];
                            visited.add(`${pos.x},${pos.y},${pos.z}`);
                        }
                    }

                    mergedQuads.push({
                        x: face.x, y: face.y, z: face.z,
                        width, height,
                        dir: face.dir,
                        color: face.color,
                        axis1, axis2
                    });
                }
            }

            return mergedQuads;
        }

        function getThirdAxis(axis1, axis2) {
            if ((axis1 === 'x' && axis2 === 'y') || (axis1 === 'y' && axis2 === 'x')) return 'z';
            if ((axis1 === 'x' && axis2 === 'z') || (axis1 === 'z' && axis2 === 'x')) return 'y';
            return 'x';
        }

        // ===== TRANSITION GEOMETRY (blend voxels into distance model) =====
        // ONLY creates voxelgons at chunk boundaries facing unloaded chunks
        function createTransitionGeometry(chunkX, chunkY, chunkZ, chunkSize, voxels) {
            const transitionQuads = [];

            // Check each voxel to see if it's at a chunk boundary facing unloaded terrain
            for (const [key, voxel] of voxels) {
                const [x, y, z] = key.split(',').map(Number);
                const worldX = chunkX * chunkSize + x;
                const worldY = chunkY * chunkSize + y;
                const worldZ = chunkZ * chunkSize + z;

                // Check 6 directions
                const neighbors = [
                    { dx: 1, dy: 0, dz: 0 },  // +X
                    { dx: -1, dy: 0, dz: 0 }, // -X
                    { dx: 0, dy: 1, dz: 0 },  // +Y
                    { dx: 0, dy: -1, dz: 0 }, // -Y
                    { dx: 0, dy: 0, dz: 1 },  // +Z
                    { dx: 0, dy: 0, dz: -1 }  // -Z
                ];

                for (const { dx, dy, dz } of neighbors) {
                    const neighborX = x + dx;
                    const neighborY = y + dy;
                    const neighborZ = z + dz;

                    // Check if neighbor is OUTSIDE current chunk (at chunk boundary)
                    const outsideChunk = neighborX < 0 || neighborX >= chunkSize ||
                                        neighborY < 0 || neighborY >= chunkSize ||
                                        neighborZ < 0 || neighborZ >= chunkSize;

                    if (outsideChunk) {
                        // Calculate which chunk the neighbor would be in
                        const neighborChunkX = chunkX + (neighborX < 0 ? -1 : (neighborX >= chunkSize ? 1 : 0));
                        const neighborChunkY = chunkY + (neighborY < 0 ? -1 : (neighborY >= chunkSize ? 1 : 0));
                        const neighborChunkZ = chunkZ + (neighborZ < 0 ? -1 : (neighborZ >= chunkSize ? 1 : 0));
                        const neighborChunkKey = chunkKey(neighborChunkX, neighborChunkY, neighborChunkZ);

                        // ONLY create voxelgon if adjacent chunk is NOT loaded
                        if (!loadedChunkMeshes.has(neighborChunkKey)) {
                            // Sample distance model to get surface point
                            const edgeX = worldX + dx * 0.5;
                            const edgeY = worldY + dy * 0.5;
                            const edgeZ = worldZ + dz * 0.5;

                            const dist = Math.sqrt(edgeX * edgeX + edgeY * edgeY + edgeZ * edgeZ);
                            const sphereX = edgeX / dist;
                            const sphereY = edgeY / dist;
                            const sphereZ = edgeZ / dist;
                            const height = getHeightAtSpherePos(sphereX, sphereY, sphereZ);
                            const surfaceRadius = planetRadius + height;

                            transitionQuads.push({
                                voxelPos: [worldX, worldY, worldZ],
                                direction: [dx, dy, dz],
                                surfacePos: [sphereX * surfaceRadius, sphereY * surfaceRadius, sphereZ * surfaceRadius],
                                color: voxel.color
                            });
                        }
                    }
                }
            }

            return transitionQuads;
        }

        // Build transition mesh from quads - "Voxelgon" stitch geometry
        // Creates quad strips between voxel edges and impostor surface
        function buildTransitionMesh(transitionQuads, chunkX, chunkY, chunkZ) {
            if (transitionQuads.length === 0) return null;

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const normals = [];

            for (const quad of transitionQuads) {
                const [vx, vy, vz] = quad.voxelPos;
                const [dx, dy, dz] = quad.direction;
                const [sx, sy, sz] = quad.surfacePos;
                const color = new THREE.Color(quad.color);

                // Generate edge line (2 vertices on voxel face)
                let edgeStart, edgeEnd, nearSurface1, nearSurface2;
                const faceOffset = 0.51; // Slightly beyond voxel to prevent z-fighting
                const stepDist = 1.0; // One block-unit away

                if (dx !== 0) {
                    // Edge perpendicular to X axis
                    const faceX = vx + dx * faceOffset;
                    const stepX = vx + dx * (faceOffset + stepDist);

                    // Pick edge based on dominant surface direction
                    const useZ = Math.abs(sz - vz) > Math.abs(sy - vy);
                    if (useZ) {
                        edgeStart = new THREE.Vector3(faceX, vy - 0.5, vz);
                        edgeEnd = new THREE.Vector3(faceX, vy + 0.5, vz);
                        nearSurface1 = new THREE.Vector3(stepX, vy - 0.5, vz);
                        nearSurface2 = new THREE.Vector3(stepX, vy + 0.5, vz);
                    } else {
                        edgeStart = new THREE.Vector3(faceX, vy, vz - 0.5);
                        edgeEnd = new THREE.Vector3(faceX, vy, vz + 0.5);
                        nearSurface1 = new THREE.Vector3(stepX, vy, vz - 0.5);
                        nearSurface2 = new THREE.Vector3(stepX, vy, vz + 0.5);
                    }
                } else if (dy !== 0) {
                    // Edge perpendicular to Y axis
                    const faceY = vy + dy * faceOffset;
                    const stepY = vy + dy * (faceOffset + stepDist);

                    const useZ = Math.abs(sz - vz) > Math.abs(sx - vx);
                    if (useZ) {
                        edgeStart = new THREE.Vector3(vx - 0.5, faceY, vz);
                        edgeEnd = new THREE.Vector3(vx + 0.5, faceY, vz);
                        nearSurface1 = new THREE.Vector3(vx - 0.5, stepY, vz);
                        nearSurface2 = new THREE.Vector3(vx + 0.5, stepY, vz);
                    } else {
                        edgeStart = new THREE.Vector3(vx, faceY, vz - 0.5);
                        edgeEnd = new THREE.Vector3(vx, faceY, vz + 0.5);
                        nearSurface1 = new THREE.Vector3(vx, stepY, vz - 0.5);
                        nearSurface2 = new THREE.Vector3(vx, stepY, vz + 0.5);
                    }
                } else if (dz !== 0) {
                    // Edge perpendicular to Z axis
                    const faceZ = vz + dz * faceOffset;
                    const stepZ = vz + dz * (faceOffset + stepDist);

                    const useX = Math.abs(sx - vx) > Math.abs(sy - vy);
                    if (useX) {
                        edgeStart = new THREE.Vector3(vx, vy - 0.5, faceZ);
                        edgeEnd = new THREE.Vector3(vx, vy + 0.5, faceZ);
                        nearSurface1 = new THREE.Vector3(vx, vy - 0.5, stepZ);
                        nearSurface2 = new THREE.Vector3(vx, vy + 0.5, stepZ);
                    } else {
                        edgeStart = new THREE.Vector3(vx - 0.5, vy, faceZ);
                        edgeEnd = new THREE.Vector3(vx + 0.5, vy, faceZ);
                        nearSurface1 = new THREE.Vector3(vx - 0.5, vy, stepZ);
                        nearSurface2 = new THREE.Vector3(vx + 0.5, vy, stepZ);
                    }
                }

                // Surface points projected from near positions
                const surfaceDir = new THREE.Vector3(sx, sy, sz).normalize();
                const surfaceDist = new THREE.Vector3(sx, sy, sz).length();

                // Project near positions onto surface sphere
                const surface1Dir = nearSurface1.clone().normalize();
                const surface2Dir = nearSurface2.clone().normalize();
                const surfacePoint1 = surface1Dir.multiplyScalar(surfaceDist - 0.05);
                const surfacePoint2 = surface2Dir.multiplyScalar(surfaceDist - 0.05);

                // VOXELGON: Two triangles forming a quad strip
                // Triangle 1: edgeStart, edgeEnd, nearSurface1 (2 on voxel edge, 1 stepping toward surface)
                vertices.push(
                    edgeStart.x, edgeStart.y, edgeStart.z,
                    edgeEnd.x, edgeEnd.y, edgeEnd.z,
                    nearSurface1.x, nearSurface1.y, nearSurface1.z
                );
                colors.push(
                    color.r, color.g, color.b,
                    color.r, color.g, color.b,
                    color.r * 0.9, color.g * 0.9, color.b * 0.9
                );

                // Calculate normal for triangle 1
                const edge1_1 = new THREE.Vector3().subVectors(edgeEnd, edgeStart);
                const edge1_2 = new THREE.Vector3().subVectors(nearSurface1, edgeStart);
                const normal1 = new THREE.Vector3().crossVectors(edge1_1, edge1_2).normalize();
                normals.push(normal1.x, normal1.y, normal1.z, normal1.x, normal1.y, normal1.z, normal1.x, normal1.y, normal1.z);

                // Triangle 2: edgeEnd, surfacePoint2, nearSurface1 (1 on voxel, 2 on surface)
                vertices.push(
                    edgeEnd.x, edgeEnd.y, edgeEnd.z,
                    surfacePoint2.x, surfacePoint2.y, surfacePoint2.z,
                    surfacePoint1.x, surfacePoint1.y, surfacePoint1.z
                );
                colors.push(
                    color.r, color.g, color.b,
                    color.r * 0.75, color.g * 0.75, color.b * 0.75,
                    color.r * 0.75, color.g * 0.75, color.b * 0.75
                );

                // Calculate normal for triangle 2
                const edge2_1 = new THREE.Vector3().subVectors(surfacePoint2, edgeEnd);
                const edge2_2 = new THREE.Vector3().subVectors(surfacePoint1, edgeEnd);
                const normal2 = new THREE.Vector3().crossVectors(edge2_1, edge2_2).normalize();
                normals.push(normal2.x, normal2.y, normal2.z, normal2.x, normal2.y, normal2.z, normal2.x, normal2.y, normal2.z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: false,
                side: THREE.DoubleSide,
                transparent: false
            });

            return new THREE.Mesh(geometry, material);
        }

        // ===== VOXEL CHUNK CLASS (from engine) =====
        class VoxelChunk {
            constructor(chunkX, chunkY, chunkZ, chunkSize = 16, lodLevel = 0) {
                this.chunkX = chunkX;
                this.chunkY = chunkY;
                this.chunkZ = chunkZ;
                this.chunkSize = chunkSize;
                this.lodLevel = lodLevel;
                this.voxels = new Map(); // 'x,y,z' -> {type, color}
                this.mesh = null;
                this.dirty = true;
            }

            buildMesh() {
                if (!this.dirty) return this.mesh;

                // Remove old mesh
                if (this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh = null;
                }

                if (this.voxels.size === 0) {
                    this.dirty = false;
                    return null;
                }

                // Helper to check if voxel exists
                const hasVoxel = (x, y, z) => {
                    // Within chunk bounds - check local voxel map
                    if (x >= 0 && x < this.chunkSize && y >= 0 && y < this.chunkSize && z >= 0 && z < this.chunkSize) {
                        return this.voxels.has(`${x},${y},${z}`);
                    }

                    // Out of chunk bounds - check neighboring chunk
                    const neighborChunkX = this.chunkX + (x < 0 ? -1 : x >= this.chunkSize ? 1 : 0);
                    const neighborChunkY = this.chunkY + (y < 0 ? -1 : y >= this.chunkSize ? 1 : 0);
                    const neighborChunkZ = this.chunkZ + (z < 0 ? -1 : z >= this.chunkSize ? 1 : 0);
                    const neighborKey = chunkKey(neighborChunkX, neighborChunkY, neighborChunkZ);

                    // Check raw planet data, not loaded chunks
                    const neighborChunk = planetChunks.get(neighborKey);
                    if (!neighborChunk) return false; // No neighbor data = exposed face

                    // Get local position in neighbor chunk
                    const localX = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize;
                    const localY = ((y % this.chunkSize) + this.chunkSize) % this.chunkSize;
                    const localZ = ((z % this.chunkSize) + this.chunkSize) % this.chunkSize;

                    return neighborChunk.voxels.has(`${localX},${localY},${localZ}`);
                };

                // Step 1: Collect all exposed faces
                const exposedFaces = [];
                for (const [key, voxel] of this.voxels) {
                    const [x, y, z] = key.split(',').map(Number);

                    // Check all 6 faces, add to list if exposed
                    if (!hasVoxel(x + 1, y, z)) exposedFaces.push({ x, y, z, dir: 'px', color: voxel.color });
                    if (!hasVoxel(x - 1, y, z)) exposedFaces.push({ x, y, z, dir: 'nx', color: voxel.color });
                    if (!hasVoxel(x, y + 1, z)) exposedFaces.push({ x, y, z, dir: 'py', color: voxel.color });
                    if (!hasVoxel(x, y - 1, z)) exposedFaces.push({ x, y, z, dir: 'ny', color: voxel.color });
                    if (!hasVoxel(x, y, z + 1)) exposedFaces.push({ x, y, z, dir: 'pz', color: voxel.color });
                    if (!hasVoxel(x, y, z - 1)) exposedFaces.push({ x, y, z, dir: 'nz', color: voxel.color });
                }

                if (exposedFaces.length === 0) {
                    this.dirty = false;
                    return null;
                }

                // Step 2: Apply greedy meshing to merge adjacent same-color faces
                const mergedQuads = greedyMeshFaces(exposedFaces);

                // Step 3: Build geometry - just render individual quads per exposed face
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const colors = [];

                for (const face of exposedFaces) {
                    const worldX = this.chunkX * this.chunkSize + face.x;
                    const worldY = this.chunkY * this.chunkSize + face.y;
                    const worldZ = this.chunkZ * this.chunkSize + face.z;

                    const c = new THREE.Color(face.color);
                    let v1, v2, v3, v4, normal;

                    if (face.dir === 'px') {
                        v1 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                        v2 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                        v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                        v4 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                        normal = [1, 0, 0];
                    } else if (face.dir === 'nx') {
                        v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                        v2 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                        v3 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                        v4 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                        normal = [-1, 0, 0];
                    } else if (face.dir === 'py') {
                        v1 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                        v2 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                        v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                        v4 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                        normal = [0, 1, 0];
                    } else if (face.dir === 'ny') {
                        v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                        v2 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                        v3 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                        v4 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                        normal = [0, -1, 0];
                    } else if (face.dir === 'pz') {
                        v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                        v2 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                        v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                        v4 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                        normal = [0, 0, 1];
                    } else if (face.dir === 'nz') {
                        v1 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                        v2 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                        v3 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                        v4 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                        normal = [0, 0, -1];
                    }

                    vertices.push(...v1, ...v2, ...v3);
                    vertices.push(...v1, ...v3, ...v4);

                    for (let i = 0; i < 6; i++) {
                        normals.push(...normal);
                        colors.push(c.r, c.g, c.b);
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true
                });

                this.mesh = new THREE.Mesh(geometry, material);

                this.dirty = false;
                return this.mesh;
            }
        }

        // ===== PROGRESSIVE CHUNK LOADER WITH LAZY PROPAGATION + LOD =====
        // Inspired by DistantHorizons - multiple detail levels based on distance
        const loadedChunkMeshes = new Map(); // 'cx,cy,cz@lod' -> VoxelChunk (currently rendering)
        const meshCache = new Map(); // 'cx,cy,cz@lod' -> THREE.Mesh (cached, not in scene)
        const CHUNK_LOAD_RADIUS = 20; // Load chunks within 20-chunk radius (320m)
        const CHUNKS_PER_FRAME = 5; // Load max 5 chunks per frame
        const MAX_CACHED_MESHES = 500; // Keep up to 500 meshes cached in memory
        let pendingChunksToLoad = []; // Queue of chunks waiting to be loaded
        let loadWaveFront = new Set(); // Chunks at the edge of loaded area (for propagation)

        // LOD distances (DistantHorizons-inspired)
        const LOD_DISTANCES = [
            { distance: 64, detail: 16 },   // LOD 0: Full detail (16³ voxels) within 64m
            { distance: 128, detail: 8 },   // LOD 1: Half detail (8³ voxels) 64-128m
            { distance: 256, detail: 4 },   // LOD 2: Quarter detail (4³ voxels) 128-256m
            { distance: 600, detail: 2 }    // LOD 3: Minimal detail (2³ voxels) 256-600m
        ];

        function getLODForDistance(dist) {
            for (let i = 0; i < LOD_DISTANCES.length; i++) {
                if (dist < LOD_DISTANCES[i].distance) {
                    return { level: i, detail: LOD_DISTANCES[i].detail };
                }
            }
            return { level: LOD_DISTANCES.length - 1, detail: LOD_DISTANCES[LOD_DISTANCES.length - 1].detail };
        }

        function updateChunkLoadQueue(playerPos) {
            const loadSphereRadius = LOD_LOAD_DISTANCE; // 600m

            // If no chunks loaded yet, find the closest chunk to player (seed point)
            if (loadedChunkMeshes.size === 0 && loadWaveFront.size === 0 && planetChunks.size > 0) {
                // Find closest chunk to player as starting seed
                let closestKey = null;
                let closestDist = Infinity;

                for (const [key, chunk] of planetChunks) {
                    const [cx, cy, cz] = key.split(',').map(Number);
                    const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
                    const chunkCenterY = cy * CHUNK_SIZE + CHUNK_SIZE / 2;
                    const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;

                    const distFromPlayer = Math.sqrt(
                        (chunkCenterX - playerPos.x) ** 2 +
                        (chunkCenterY - playerPos.y) ** 2 +
                        (chunkCenterZ - playerPos.z) ** 2
                    );

                    if (distFromPlayer < closestDist) {
                        closestDist = distFromPlayer;
                        closestKey = key;
                    }
                }

                if (closestKey) {
                    loadWaveFront.add(closestKey);
                }
            }

            // Propagate from wavefront (lazy async spreading)
            const chunksToLoad = [];

            // Add neighbors of loaded chunks to wavefront
            const newWaveFront = new Set();
            for (const key of loadWaveFront) {
                const [cx, cy, cz] = key.split(',').map(Number);

                // Check 6 neighbors (up, down, left, right, forward, back)
                const neighbors = [
                    [cx + 1, cy, cz],
                    [cx - 1, cy, cz],
                    [cx, cy + 1, cz],
                    [cx, cy - 1, cz],
                    [cx, cy, cz + 1],
                    [cx, cy, cz - 1]
                ];

                for (const [nx, ny, nz] of neighbors) {
                    const neighborKey = chunkKey(nx, ny, nz);

                    // Only propagate if: (1) chunk exists, (2) not loaded, (3) within load radius
                    if (planetChunks.has(neighborKey) && !loadedChunkMeshes.has(neighborKey)) {
                        const chunkCenterX = nx * CHUNK_SIZE + CHUNK_SIZE / 2;
                        const chunkCenterY = ny * CHUNK_SIZE + CHUNK_SIZE / 2;
                        const chunkCenterZ = nz * CHUNK_SIZE + CHUNK_SIZE / 2;

                        const distFromPlayer = Math.sqrt(
                            (chunkCenterX - playerPos.x) ** 2 +
                            (chunkCenterY - playerPos.y) ** 2 +
                            (chunkCenterZ - playerPos.z) ** 2
                        );

                        if (distFromPlayer <= loadSphereRadius) {
                            const distFromCenter = Math.sqrt(
                                chunkCenterX ** 2 +
                                chunkCenterY ** 2 +
                                chunkCenterZ ** 2
                            );

                            chunksToLoad.push({ cx: nx, cy: ny, cz: nz, distFromCenter, distFromPlayer });
                            newWaveFront.add(neighborKey); // This becomes new edge
                        }
                    }
                }
            }

            // Sort by distance from player (ASCENDING - closest neighbors load first for organic spread)
            chunksToLoad.sort((a, b) => a.distFromPlayer - b.distFromPlayer);

            // Update wavefront with new edges
            loadWaveFront = newWaveFront;

            // Update pending queue
            pendingChunksToLoad = chunksToLoad;
        }

        function loadNextChunksFromQueue() {
            // Load up to CHUNKS_PER_FRAME chunks this frame
            const chunksToProcess = pendingChunksToLoad.splice(0, CHUNKS_PER_FRAME);

            for (const { cx, cy, cz } of chunksToProcess) {
                const key = chunkKey(cx, cy, cz);

                // Check if mesh is already cached (instant!)
                const cachedMesh = meshCache.get(key);
                if (cachedMesh) {
                    // Reuse cached mesh - just add to scene
                    scene.add(cachedMesh);
                    const voxelChunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE);
                    voxelChunk.mesh = cachedMesh;
                    voxelChunk.dirty = false;
                    loadedChunkMeshes.set(key, voxelChunk);
                    loadWaveFront.add(key);
                    meshCache.delete(key); // Remove from cache since it's now active
                    continue;
                }

                // Fetch chunk from pre-generated data (simulates server fetch)
                const rawChunk = planetChunks.get(key);
                if (!rawChunk) continue; // Skip non-existent chunks

                // Create VoxelChunk and build mesh
                const voxelChunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE);
                voxelChunk.voxels = rawChunk.voxels; // Reference voxel data

                // Build optimized mesh using engine method
                const mesh = voxelChunk.buildMesh();
                if (mesh) {
                    scene.add(mesh);
                    loadedChunkMeshes.set(key, voxelChunk);

                    // Add to wavefront for propagation (this chunk can now spread to neighbors)
                    loadWaveFront.add(key);
                }

                // Separate pass: Load build references in this chunk
                if (rawChunk.buildRefs && rawChunk.buildRefs.length > 0) {
                    for (const buildRef of rawChunk.buildRefs) {
                        loadBuildReference(buildRef);
                    }
                }
            }
        }

        // Load a build reference (separate from planet terrain)
        async function loadBuildReference(buildRef) {
            const { buildId, mvox_id, position, rotation, scale_ratio } = buildRef;

            // Skip if already loaded
            if (loadedBuilds.has(buildId)) return;

            // Fetch build data
            const buildData = await fetchBuildMvox(mvox_id);
            if (!buildData) return;

            // Create VoxelChunk for build at specified position
            const buildChunk = new VoxelChunk(0, 0, 0, CHUNK_SIZE);
            buildChunk.voxels = buildData.voxels;

            const buildMesh = buildChunk.buildMesh();
            if (buildMesh) {
                // Apply position, rotation, scale
                buildMesh.position.set(position[0], position[1], position[2]);
                buildMesh.rotation.set(rotation[0] * Math.PI / 180, rotation[1] * Math.PI / 180, rotation[2] * Math.PI / 180);
                buildMesh.scale.setScalar(scale_ratio);

                scene.add(buildMesh);
                loadedBuilds.set(buildId, buildChunk);
            }
        }

        // Unload chunks that are too far from player (but cache them!)
        function unloadDistantChunks(playerPos) {
            const UNLOAD_DISTANCE = CHUNK_LOAD_RADIUS * CHUNK_SIZE * 1.5; // Unload beyond 1.5x load radius

            for (const [key, voxelChunk] of loadedChunkMeshes) {
                const [cx, cy, cz] = key.split(',').map(Number);
                const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterY = cy * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;

                const distFromPlayer = Math.sqrt(
                    (chunkCenterX - playerPos.x) ** 2 +
                    (chunkCenterY - playerPos.y) ** 2 +
                    (chunkCenterZ - playerPos.z) ** 2
                );

                if (distFromPlayer > UNLOAD_DISTANCE) {
                    // Remove voxel mesh from scene but CACHE it for later
                    if (voxelChunk.mesh) {
                        scene.remove(voxelChunk.mesh);

                        // Cache mesh if we have room
                        if (meshCache.size < MAX_CACHED_MESHES) {
                            meshCache.set(key, voxelChunk.mesh);
                        } else {
                            // Cache full - dispose oldest cached mesh and replace it
                            const oldestKey = meshCache.keys().next().value;
                            const oldestMesh = meshCache.get(oldestKey);
                            if (oldestMesh && oldestMesh.geometry) {
                                oldestMesh.geometry.dispose();
                            }
                            meshCache.delete(oldestKey);
                            meshCache.set(key, voxelChunk.mesh);
                        }
                    }

                    loadedChunkMeshes.delete(key);
                }
            }
        }

        // Automatic LOD switch based on distance
        const LOD_LOAD_DISTANCE = 600;   // Start loading chunks at 600m from surface
        const LOD_UNLOAD_DISTANCE = 1200; // Fully unload all chunks when >1200m from surface

        function updateLOD() {
            const distToSurface = camera.position.length() - planetRadius;

            // Load chunks progressively if close enough
            if (distToSurface < LOD_LOAD_DISTANCE) {
                updateChunkLoadQueue(camera.position);
                loadNextChunksFromQueue(); // Progressive loading (5 chunks per frame)
                unloadDistantChunks(camera.position); // Unload chunks beyond 1.5x load radius
            } else {
                // Clear pending queue when outside load range
                pendingChunksToLoad = [];
            }

            // Emergency unload: Unload ALL chunks if FAR away (hysteresis prevents constant reload)
            if (distToSurface > LOD_UNLOAD_DISTANCE) {
                for (const [key, voxelChunk] of loadedChunkMeshes) {
                    if (voxelChunk.mesh) {
                        scene.remove(voxelChunk.mesh);
                        if (voxelChunk.mesh.geometry) {
                            voxelChunk.mesh.geometry.dispose();
                        }
                        voxelChunk.mesh = null;
                    }
                }
                loadedChunkMeshes.clear();
                pendingChunksToLoad = [];
            }

            const chunkCount = loadedChunkMeshes.size;

            // Keep impostor mesh ALWAYS visible - shader handles per-chunk culling
            // This prevents gaps/artifacts when voxels haven't loaded yet
            planetMesh.visible = true;

            // CRITICAL: Update 3D texture EVERY FRAME for per-chunk culling
            // Clear texture data
            chunkTextureData.fill(0);

            // Mark loaded chunks in texture
            for (const [key, voxelChunk] of loadedChunkMeshes) {
                const [cx, cy, cz] = key.split(',').map(Number);

                // Convert chunk coordinate to texture index (offset by half size for negative coords)
                const tx = Math.floor(cx + CHUNK_TEXTURE_SIZE / 2);
                const ty = Math.floor(cy + CHUNK_TEXTURE_SIZE / 2);
                const tz = Math.floor(cz + CHUNK_TEXTURE_SIZE / 2);

                // Bounds check
                if (tx >= 0 && tx < CHUNK_TEXTURE_SIZE &&
                    ty >= 0 && ty < CHUNK_TEXTURE_SIZE &&
                    tz >= 0 && tz < CHUNK_TEXTURE_SIZE) {

                    const index = tx + ty * CHUNK_TEXTURE_SIZE + tz * CHUNK_TEXTURE_SIZE * CHUNK_TEXTURE_SIZE;
                    chunkTextureData[index] = 255; // Mark as loaded
                }
            }

            // Update texture on GPU
            chunkTexture.needsUpdate = true;

            // Update UI
            let mode = 'MESH (impostor)';
            if (chunkCount > 0) mode = `MESH + VOXELS (${chunkCount} chunks loaded, ${pendingChunksToLoad.length} pending)`;
            document.getElementById('mode').textContent = `Rendering: ${mode}`;
            document.getElementById('distance').textContent = Math.round(distToSurface);
        }

        // Camera controls
        let mouseDown = false;
        let cameraAngle = { theta: 0, phi: Math.PI / 4 };
        let cameraDistance = 400;

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                cameraAngle.theta += e.movementX * 0.01;
                cameraAngle.phi += e.movementY * 0.01;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.phi));
            }
        });
        document.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.5;
            cameraDistance = Math.max(160, Math.min(800, cameraDistance)); // Allow zooming to surface (planet radius 150 + margin)
        });

        // FPS and memory tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);

            try {
                // FPS calculation
                frameCount++;
                const currentTime = performance.now();
                const deltaTime = currentTime - lastTime;

                if (deltaTime >= 1000) { // Update every second
                    fps = Math.round((frameCount * 1000) / deltaTime);
                    frameCount = 0;
                    lastTime = currentTime;

                    // Update FPS display
                    document.getElementById('fps').textContent = fps;

                    // Update memory display (if available)
                    if (performance.memory) {
                        // Use totalJSHeapSize instead of usedJSHeapSize for more accurate reading
                        // This includes allocated but not yet used memory
                        const memoryMB = Math.round(performance.memory.totalJSHeapSize / 1048576);
                        const usedMB = Math.round(performance.memory.usedJSHeapSize / 1048576);

                        // Get WebGL memory info (GPU memory usage)
                        const glInfo = renderer.info.memory;
                        const gpuInfo = ` (Geo: ${glInfo.geometries}, Tex: ${glInfo.textures})`;

                        document.getElementById('memory').textContent = memoryMB + gpuInfo;
                    } else {
                        document.getElementById('memory').textContent = 'N/A';
                    }
                }

                camera.position.set(
                    cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta),
                    cameraDistance * Math.cos(cameraAngle.phi),
                    cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta)
                );
                camera.lookAt(0, 0, 0);

                // Update LOD based on distance
                updateLOD();

                renderer.render(scene, camera);
            } catch (error) {
                console.error('[RENDER ERROR]', error);
            }
        }

        // Wait for planet data to load, then start animation
        initializePlanetData().then(() => {
            try {
                animate();
            } catch (error) {
                console.error('[INIT ERROR]', error);
            }

            // Log THREE.js version and capabilities
            console.log('THREE.js version:', THREE.REVISION);
            console.log('WebGL capabilities:', renderer.capabilities);
        });
    </script>
</body>
</html>
