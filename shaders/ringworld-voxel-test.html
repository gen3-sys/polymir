<!DOCTYPE html>
<html>
<head>
    <title>Ringworld Voxel Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        FPS: <span id="fps">0</span> | Memory: <span id="memory">0</span> MB<br>
        WASD to move, Mouse to look<br>
        <span id="mode">Rendering: RINGWORLD</span><br>
        Chunks loaded: <span id="chunks">0</span><br>
        Position: <span id="position">0, 0, 0</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Ringworld parameters
        const RING_MAJOR_RADIUS = 500; // Distance from center to ring centerline
        const RING_MINOR_RADIUS = 100; // Half-width of the ring surface
        const RING_THICKNESS = 50;      // Depth of habitable surface
        const CHUNK_SIZE = 16;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(RING_MAJOR_RADIUS, 10, 0); // Start on ring surface

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(0, 500, 0); // Sun at axis center
        scene.add(sun);

        // Ringworld chunk storage
        const ringChunks = new Map(); // 'cx,cy,cz' -> { voxels: Map }
        const loadedChunkMeshes = new Map();
        const CHUNK_LOAD_RADIUS = 10;
        const CHUNKS_PER_FRAME = 5;
        let pendingChunksToLoad = [];

        function chunkKey(cx, cy, cz) {
            return `${cx},${cy},${cz}`;
        }

        // ===== NOISE FUNCTIONS (from planet test) =====
        function hash(x, y, z) {
            let p = { x: x * 443.897, y: y * 441.423, z: z * 437.195 };
            p.x = p.x - Math.floor(p.x);
            p.y = p.y - Math.floor(p.y);
            p.z = p.z - Math.floor(p.z);

            const dotProduct = p.x * (p.y + 19.19) + p.y * (p.x + 19.19) + p.z * (p.z + 19.19);
            p.x += dotProduct;
            p.y += dotProduct;
            p.z += dotProduct;

            const result = (p.x + p.y) * p.z;
            return result - Math.floor(result);
        }

        function noise3d(x, y, z) {
            const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
            const fx = x - ix, fy = y - iy, fz = z - iz;
            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);
            const sz = fz * fz * (3 - 2 * fz);

            const c000 = hash(ix, iy, iz);
            const c100 = hash(ix + 1, iy, iz);
            const c010 = hash(ix, iy + 1, iz);
            const c110 = hash(ix + 1, iy + 1, iz);
            const c001 = hash(ix, iy, iz + 1);
            const c101 = hash(ix + 1, iy, iz + 1);
            const c011 = hash(ix, iy + 1, iz + 1);
            const c111 = hash(ix + 1, iy + 1, iz + 1);

            const k0 = c000 + (c100 - c000) * sx;
            const k1 = c010 + (c110 - c010) * sx;
            const k2 = c001 + (c101 - c001) * sx;
            const k3 = c011 + (c111 - c011) * sx;
            const k4 = k0 + (k1 - k0) * sy;
            const k5 = k2 + (k3 - k2) * sy;

            return k4 + (k5 - k4) * sz;
        }

        // Get height at surface position (adapted for torus)
        function getHeightAtTorusSurface(normX, normY, normZ) {
            let height = 0;
            height += (noise3d(normX * 2, normY * 2, normZ * 2) - 0.5) * 15;
            height += (noise3d(normX * 5, normY * 5, normZ * 5) - 0.5) * 8;
            height += (noise3d(normX * 12, normY * 12, normZ * 12) - 0.5) * 4;
            height += (noise3d(normX * 25, normY * 25, normZ * 25) - 0.5) * 2;
            return height * 0.5;
        }

        // Get terrain color (from planet test)
        function getTerrainColor(height) {
            if (height < -5) return 0x2269B0; // Deep ocean
            if (height < 0) return 0x4D96C7;   // Shallow water
            if (height < 2) return 0xC2B380;   // Beach
            if (height < 10) return 0x4D9A4D;  // Grassland
            if (height < 18) return 0x3D833D;  // Forest
            if (height < 25) return 0x786358;  // Mountains
            return 0xF0F0FA;                   // Snow
        }

        // Generate voxel data from torus with terrain
        function generateRingworldChunk(cx, cy, cz) {
            const chunkWorldX = cx * CHUNK_SIZE;
            const chunkWorldY = cy * CHUNK_SIZE;
            const chunkWorldZ = cz * CHUNK_SIZE;

            const chunk = { voxels: new Map() };
            let chunkVoxelCount = 0;

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let y = 0; y < CHUNK_SIZE; y++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = chunkWorldX + x;
                        const worldY = chunkWorldY + y;
                        const worldZ = chunkWorldZ + z;

                        // Torus coordinates
                        const distFromAxis = Math.sqrt(worldX * worldX + worldZ * worldZ);
                        const ringOffset = distFromAxis - RING_MAJOR_RADIUS;
                        const distFromRing = Math.sqrt(ringOffset * ringOffset + worldY * worldY);

                        // Get normalized position on torus surface (for noise sampling)
                        const torusU = Math.atan2(worldZ, worldX); // Angle around ring
                        const torusV = Math.atan2(worldY, ringOffset); // Angle around tube

                        // Convert to 3D surface position for noise
                        const normX = Math.cos(torusU) * Math.cos(torusV);
                        const normY = Math.sin(torusV);
                        const normZ = Math.sin(torusU) * Math.cos(torusV);

                        // Get terrain height at this surface position
                        const height = getHeightAtTorusSurface(normX, normY, normZ);
                        const surfaceRadius = RING_MINOR_RADIUS + height;

                        // Check if voxel is solid (between inner and surface)
                        if (distFromRing <= surfaceRadius && distFromRing >= surfaceRadius - RING_THICKNESS) {
                            const color = getTerrainColor(height);
                            chunk.voxels.set(`${x},${y},${z}`, { color });
                            chunkVoxelCount++;
                        }
                    }
                }
            }

            return chunkVoxelCount > 0 ? chunk : null;
        }

        // Step 1: Generate complete ringworld .mvox data
        function generateRingworldMvox() {
            console.log('Step 1: Generating complete ringworld voxel data...');

            const allVoxels = new Map(); // All voxels in world coordinates

            const chunkRadiusInner = Math.floor((RING_MAJOR_RADIUS - RING_MINOR_RADIUS) / CHUNK_SIZE) - 2;
            const chunkRadiusOuter = Math.ceil((RING_MAJOR_RADIUS + RING_MINOR_RADIUS) / CHUNK_SIZE) + 2;
            const chunkHeightMin = Math.floor(-RING_MINOR_RADIUS / CHUNK_SIZE) - 2;
            const chunkHeightMax = Math.ceil(RING_MINOR_RADIUS / CHUNK_SIZE) + 2;

            for (let cy = chunkHeightMin; cy <= chunkHeightMax; cy++) {
                for (let cx = -chunkRadiusOuter; cx <= chunkRadiusOuter; cx++) {
                    for (let cz = -chunkRadiusOuter; cz <= chunkRadiusOuter; cz++) {
                        const chunk = generateRingworldChunk(cx, cy, cz);
                        if (chunk) {
                            for (const [localKey, voxel] of chunk.voxels) {
                                const [x, y, z] = localKey.split(',').map(Number);
                                const worldX = cx * CHUNK_SIZE + x;
                                const worldY = cy * CHUNK_SIZE + y;
                                const worldZ = cz * CHUNK_SIZE + z;
                                allVoxels.set(`${worldX},${worldY},${worldZ}`, voxel);
                            }
                        }
                    }
                }
            }

            const mvoxData = {
                header: {
                    version: 1,
                    type: "ringworld",
                    compression: "none",
                    metadata: {
                        ring_major_radius: RING_MAJOR_RADIUS,
                        ring_minor_radius: RING_MINOR_RADIUS,
                        ring_thickness: RING_THICKNESS,
                        voxel_count: allVoxels.size
                    }
                },
                voxels: {}
            };

            for (const [key, voxel] of allVoxels) {
                mvoxData.voxels[key] = voxel;
            }

            console.log(`Generated .mvox with ${allVoxels.size} voxels`);
            return mvoxData;
        }

        // Step 2: Load .mvox data into chunks
        function loadRingworldFromMvox(mvoxData) {
            console.log('Step 2: Loading ringworld from .mvox data...');

            const allVoxels = new Map(Object.entries(mvoxData.voxels));

            const chunkRadiusOuter = Math.ceil((RING_MAJOR_RADIUS + RING_MINOR_RADIUS) / CHUNK_SIZE) + 2;
            const chunkHeightMin = Math.floor(-RING_MINOR_RADIUS / CHUNK_SIZE) - 2;
            const chunkHeightMax = Math.ceil(RING_MINOR_RADIUS / CHUNK_SIZE) + 2;

            for (let cy = chunkHeightMin; cy <= chunkHeightMax; cy++) {
                for (let cx = -chunkRadiusOuter; cx <= chunkRadiusOuter; cx++) {
                    for (let cz = -chunkRadiusOuter; cz <= chunkRadiusOuter; cz++) {
                        const chunkWorldX = cx * CHUNK_SIZE;
                        const chunkWorldY = cy * CHUNK_SIZE;
                        const chunkWorldZ = cz * CHUNK_SIZE;

                        const chunk = { voxels: new Map() };
                        let hasVoxels = false;

                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            for (let y = 0; y < CHUNK_SIZE; y++) {
                                for (let z = 0; z < CHUNK_SIZE; z++) {
                                    const worldKey = `${chunkWorldX + x},${chunkWorldY + y},${chunkWorldZ + z}`;
                                    if (allVoxels.has(worldKey)) {
                                        chunk.voxels.set(`${x},${y},${z}`, allVoxels.get(worldKey));
                                        hasVoxels = true;
                                    }
                                }
                            }
                        }

                        if (hasVoxels) {
                            ringChunks.set(chunkKey(cx, cy, cz), chunk);
                        }
                    }
                }
            }

            console.log(`Loaded ${ringChunks.size} chunks from .mvox`);
        }

        // Initialize: Generate .mvox then load from it
        function initializeRingworldData() {
            const mvoxData = generateRingworldMvox();
            loadRingworldFromMvox(mvoxData);
        }

        // VoxelChunk class (from planet test)
        class VoxelChunk {
            constructor(chunkX, chunkY, chunkZ, chunkSize = 16) {
                this.chunkX = chunkX;
                this.chunkY = chunkY;
                this.chunkZ = chunkZ;
                this.chunkSize = chunkSize;
                this.voxels = new Map();
                this.mesh = null;
                this.dirty = true;
            }

            buildMesh() {
                if (!this.dirty) return this.mesh;

                if (this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh = null;
                }

                if (this.voxels.size === 0) {
                    this.dirty = false;
                    return null;
                }

                // Face culling helper
                const hasVoxel = (x, y, z) => {
                    if (x >= 0 && x < this.chunkSize && y >= 0 && y < this.chunkSize && z >= 0 && z < this.chunkSize) {
                        return this.voxels.has(`${x},${y},${z}`);
                    }

                    const neighborChunkX = this.chunkX + (x < 0 ? -1 : x >= this.chunkSize ? 1 : 0);
                    const neighborChunkY = this.chunkY + (y < 0 ? -1 : y >= this.chunkSize ? 1 : 0);
                    const neighborChunkZ = this.chunkZ + (z < 0 ? -1 : z >= this.chunkSize ? 1 : 0);
                    const neighborKey = chunkKey(neighborChunkX, neighborChunkY, neighborChunkZ);

                    const neighborChunk = ringChunks.get(neighborKey);
                    if (!neighborChunk) return false;

                    const localX = ((x % this.chunkSize) + this.chunkSize) % this.chunkSize;
                    const localY = ((y % this.chunkSize) + this.chunkSize) % this.chunkSize;
                    const localZ = ((z % this.chunkSize) + this.chunkSize) % this.chunkSize;

                    return neighborChunk.voxels.has(`${localX},${localY},${localZ}`);
                };

                // Build geometry with face culling
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const colors = [];

                for (const [key, voxel] of this.voxels) {
                    const [x, y, z] = key.split(',').map(Number);
                    const worldX = this.chunkX * this.chunkSize + x;
                    const worldY = this.chunkY * this.chunkSize + y;
                    const worldZ = this.chunkZ * this.chunkSize + z;

                    const c = new THREE.Color(voxel.color);

                    // Check each face
                    const addFace = (dir) => {
                        let v1, v2, v3, v4, normal;

                        if (dir === 'px') {
                            v1 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                            v2 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                            v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                            v4 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                            normal = [1, 0, 0];
                        } else if (dir === 'nx') {
                            v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                            v2 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                            v3 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                            v4 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                            normal = [-1, 0, 0];
                        } else if (dir === 'py') {
                            v1 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                            v2 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                            v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                            v4 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                            normal = [0, 1, 0];
                        } else if (dir === 'ny') {
                            v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                            v2 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                            v3 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                            v4 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                            normal = [0, -1, 0];
                        } else if (dir === 'pz') {
                            v1 = [worldX - 0.5, worldY - 0.5, worldZ + 0.5];
                            v2 = [worldX + 0.5, worldY - 0.5, worldZ + 0.5];
                            v3 = [worldX + 0.5, worldY + 0.5, worldZ + 0.5];
                            v4 = [worldX - 0.5, worldY + 0.5, worldZ + 0.5];
                            normal = [0, 0, 1];
                        } else if (dir === 'nz') {
                            v1 = [worldX + 0.5, worldY - 0.5, worldZ - 0.5];
                            v2 = [worldX - 0.5, worldY - 0.5, worldZ - 0.5];
                            v3 = [worldX - 0.5, worldY + 0.5, worldZ - 0.5];
                            v4 = [worldX + 0.5, worldY + 0.5, worldZ - 0.5];
                            normal = [0, 0, -1];
                        }

                        vertices.push(...v1, ...v2, ...v3);
                        vertices.push(...v1, ...v3, ...v4);

                        for (let i = 0; i < 6; i++) {
                            normals.push(...normal);
                            colors.push(c.r, c.g, c.b);
                        }
                    };

                    if (!hasVoxel(x + 1, y, z)) addFace('px');
                    if (!hasVoxel(x - 1, y, z)) addFace('nx');
                    if (!hasVoxel(x, y + 1, z)) addFace('py');
                    if (!hasVoxel(x, y - 1, z)) addFace('ny');
                    if (!hasVoxel(x, y, z + 1)) addFace('pz');
                    if (!hasVoxel(x, y, z - 1)) addFace('nz');
                }

                if (vertices.length === 0) {
                    this.dirty = false;
                    return null;
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.dirty = false;
                return this.mesh;
            }
        }

        // Chunk loading system
        function updateChunkLoadQueue(playerPos) {
            pendingChunksToLoad = [];

            for (const [key, chunk] of ringChunks) {
                if (loadedChunkMeshes.has(key)) continue;

                const [cx, cy, cz] = key.split(',').map(Number);
                const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterY = cy * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;

                const distFromPlayer = Math.sqrt(
                    (chunkCenterX - playerPos.x) ** 2 +
                    (chunkCenterY - playerPos.y) ** 2 +
                    (chunkCenterZ - playerPos.z) ** 2
                );

                if (distFromPlayer <= CHUNK_LOAD_RADIUS * CHUNK_SIZE) {
                    pendingChunksToLoad.push({ cx, cy, cz, distFromPlayer });
                }
            }

            pendingChunksToLoad.sort((a, b) => a.distFromPlayer - b.distFromPlayer);
        }

        function loadNextChunksFromQueue() {
            const chunksToProcess = pendingChunksToLoad.splice(0, CHUNKS_PER_FRAME);

            for (const { cx, cy, cz } of chunksToProcess) {
                const key = chunkKey(cx, cy, cz);
                const rawChunk = ringChunks.get(key);
                if (!rawChunk) continue;

                const voxelChunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE);
                voxelChunk.voxels = rawChunk.voxels;

                const mesh = voxelChunk.buildMesh();
                if (mesh) {
                    scene.add(mesh);
                    loadedChunkMeshes.set(key, voxelChunk);
                }
            }
        }

        function unloadDistantChunks(playerPos) {
            const UNLOAD_DISTANCE = CHUNK_LOAD_RADIUS * CHUNK_SIZE * 1.5;

            for (const [key, voxelChunk] of loadedChunkMeshes) {
                const [cx, cy, cz] = key.split(',').map(Number);
                const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterY = cy * CHUNK_SIZE + CHUNK_SIZE / 2;
                const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;

                const distFromPlayer = Math.sqrt(
                    (chunkCenterX - playerPos.x) ** 2 +
                    (chunkCenterY - playerPos.y) ** 2 +
                    (chunkCenterZ - playerPos.z) ** 2
                );

                if (distFromPlayer > UNLOAD_DISTANCE) {
                    if (voxelChunk.mesh) {
                        scene.remove(voxelChunk.mesh);
                        voxelChunk.mesh.geometry.dispose();
                        voxelChunk.mesh = null;
                    }
                    loadedChunkMeshes.delete(key);
                }
            }
        }

        // FPS camera controls
        const moveSpeed = 20;
        const keys = {};
        let yaw = 0, pitch = 0;

        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });

        document.body.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        // FPS and memory tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);

            frameCount++;
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;

            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount / deltaTime);
                frameCount = 0;
                lastTime = currentTime;

                document.getElementById('fps').textContent = fps;

                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.totalJSHeapSize / 1048576);
                    const glInfo = renderer.info.memory;
                    document.getElementById('memory').textContent = `${memoryMB} (Geo: ${glInfo.geometries})`;
                }

                document.getElementById('chunks').textContent = loadedChunkMeshes.size;
            }

            // Update camera movement (fixed deltaTime)
            const dt = 0.016; // Fixed 60fps timestep for consistent movement

            const forward = new THREE.Vector3(
                Math.sin(yaw) * Math.cos(pitch),
                -Math.sin(pitch),
                Math.cos(yaw) * Math.cos(pitch)
            );
            const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

            if (keys['w']) camera.position.addScaledVector(forward, moveSpeed * dt);
            if (keys['s']) camera.position.addScaledVector(forward, -moveSpeed * dt);
            if (keys['a']) camera.position.addScaledVector(right, -moveSpeed * dt);
            if (keys['d']) camera.position.addScaledVector(right, moveSpeed * dt);

            camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));

            // Update chunk loading
            updateChunkLoadQueue(camera.position);
            loadNextChunksFromQueue();
            unloadDistantChunks(camera.position);

            document.getElementById('position').textContent =
                `${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`;

            renderer.render(scene, camera);
        }

        // Initialize and start
        initializeRingworldData();
        animate();

        console.log('Ringworld test ready');
    </script>
</body>
</html>
