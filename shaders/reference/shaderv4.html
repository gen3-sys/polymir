<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Atmospheric Shader Configurator - Polymir Engine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Left sidebar controls */
        #controls-panel {
            width: 340px;
            background: #151515;
            border-right: 1px solid #2a2a2a;
            overflow-y: auto;
            flex-shrink: 0;
        }

        #controls-header {
            padding: 15px 20px;
            background: linear-gradient(180deg, #1a1a1a 0%, #151515 100%);
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #controls-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .lod-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .lod-btn {
            flex: 1;
            padding: 6px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lod-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: #fff;
        }

        .control-group {
            margin: 0;
            padding: 20px;
            border-bottom: 1px solid #2a2a2a;
        }

        .control-group h3 {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slider-container {
            margin: 12px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
            color: #aaa;
        }

        .slider-value {
            color: #667eea;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .color-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .color-input label {
            flex: 1;
            font-size: 11px;
            color: #aaa;
        }

        .color-input input[type="color"] {
            width: 40px;
            height: 24px;
            border: 1px solid #444;
            border-radius: 3px;
            background: #1a1a1a;
            cursor: pointer;
        }

        .color-hex {
            font-size: 10px;
            color: #667eea;
            font-family: monospace;
            width: 60px;
        }

        /* Main content area */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #header {
            padding: 10px 20px;
            background: linear-gradient(180deg, #1a1a1a 0%, #151515 100%);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #header h1 {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .export-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 6px 16px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Viewport grid */
        #viewport-container {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
            background: #0f0f0f;
        }

        .viewport-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .viewport-header {
            padding: 8px 12px;
            background: linear-gradient(180deg, #222 0%, #1a1a1a 100%);
            border-bottom: 1px solid #333;
        }

        .viewport-title {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
        }

        .viewport-info {
            font-size: 10px;
            color: #888;
        }

        .viewport-canvas {
            flex: 1;
            width: 100%;
            min-height: 200px;
            display: block;
            background: #0a0a0a;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .checkbox-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-container label {
            font-size: 11px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="controls-panel">
        <div id="controls-header">
            <h2>Atmospheric Configuration</h2>
            <div class="lod-selector">
                <button class="lod-btn active" data-lod="0">Ultra</button>
                <button class="lod-btn" data-lod="1">High</button>
                <button class="lod-btn" data-lod="2">Medium</button>
                <button class="lod-btn" data-lod="3">Low</button>
            </div>
        </div>

        <div class="control-group">
            <h3>Performance Settings</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Ray March Steps</span>
                    <span class="slider-value" id="rayStepsValue">128</span>
                </div>
                <input type="range" id="raySteps" min="4" max="256" step="4" value="128">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Noise Octaves</span>
                    <span class="slider-value" id="noiseOctavesValue">5</span>
                </div>
                <input type="range" id="noiseOctaves" min="1" max="8" step="1" value="5">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Shadow Samples</span>
                    <span class="slider-value" id="shadowSamplesValue">8</span>
                </div>
                <input type="range" id="shadowSamples" min="0" max="16" step="1" value="8">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Cloud Detail Level</span>
                    <span class="slider-value" id="cloudDetailValue">1.0</span>
                </div>
                <input type="range" id="cloudDetail" min="0" max="2" step="0.1" value="1.0">
            </div>
        </div>

        <div class="control-group">
            <h3>Gravity Configuration</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Sphere Radius</span>
                    <span class="slider-value" id="sphereRadiusValue">1000</span>
                </div>
                <input type="range" id="sphereRadius" min="100" max="5000" step="100" value="1000">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Torus Major Radius</span>
                    <span class="slider-value" id="torusMajorValue">1000</span>
                </div>
                <input type="range" id="torusMajor" min="100" max="5000" step="100" value="1000">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Torus Minor Radius</span>
                    <span class="slider-value" id="torusMinorValue">100</span>
                </div>
                <input type="range" id="torusMinor" min="50" max="1000" step="50" value="100">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Cloud Height (%radius)</span>
                    <span class="slider-value" id="cloudHeightValue">5.0%</span>
                </div>
                <input type="range" id="cloudHeight" min="0.1" max="10" step="0.1" value="5.0">
            </div>
        </div>

        <div class="control-group">
            <h3>Cloud Parameters</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Coverage</span>
                    <span class="slider-value" id="cloudCoverageValue">0.60</span>
                </div>
                <input type="range" id="cloudCoverage" min="0" max="1" step="0.01" value="0.6">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Scale</span>
                    <span class="slider-value" id="cloudScaleValue">1.0</span>
                </div>
                <input type="range" id="cloudScale" min="0.1" max="5" step="0.1" value="1.0">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Density</span>
                    <span class="slider-value" id="cloudDensityValue">1.5</span>
                </div>
                <input type="range" id="cloudDensity" min="0.1" max="10" step="0.1" value="1.5">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Translucency</span>
                    <span class="slider-value" id="cloudTranslucencyValue">0.5</span>
                </div>
                <input type="range" id="cloudTranslucency" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Brightness</span>
                    <span class="slider-value" id="cloudBrightnessValue">1.0</span>
                </div>
                <input type="range" id="cloudBrightness" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Wind Speed</span>
                    <span class="slider-value" id="windSpeedValue">0.3</span>
                </div>
                <input type="range" id="windSpeed" min="0" max="2" step="0.1" value="0.3">
            </div>
        </div>

        <div class="control-group">
            <h3>Weather Systems</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Storm Clustering</span>
                    <span class="slider-value" id="stormClusteringValue">0.5</span>
                </div>
                <input type="range" id="stormClustering" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Storm Intensity</span>
                    <span class="slider-value" id="stormIntensityValue">0.3</span>
                </div>
                <input type="range" id="stormIntensity" min="0" max="1" step="0.01" value="0.3">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Vertical Development</span>
                    <span class="slider-value" id="verticalDevValue">0.4</span>
                </div>
                <input type="range" id="verticalDev" min="0" max="1" step="0.01" value="0.4">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>God Rays</span>
                    <span class="slider-value" id="godRaysValue">0.5</span>
                </div>
                <input type="range" id="godRays" min="0" max="1" step="0.01" value="0.5">
            </div>
        </div>

        <div class="control-group">
            <h3>Star System (Emergent Lighting)</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Distance to Sun (AU)</span>
                    <span class="slider-value" id="sunDistanceValue">1.0</span>
                </div>
                <input type="range" id="sunDistance" min="0.1" max="10" step="0.1" value="1.0">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Sun Radius (Solar)</span>
                    <span class="slider-value" id="sunRadiusValue">1.0</span>
                </div>
                <input type="range" id="sunRadius" min="0.5" max="3" step="0.1" value="1.0">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Sun Temperature (K)</span>
                    <span class="slider-value" id="sunTempValue">5778</span>
                </div>
                <input type="range" id="sunTemp" min="3000" max="10000" step="100" value="5778">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Sun Angle</span>
                    <span class="slider-value" id="sunAngleValue">45°</span>
                </div>
                <input type="range" id="sunAngle" min="0" max="180" step="1" value="45">
            </div>
            <div class="color-input">
                <label>Sky Top</label>
                <input type="color" id="skyColorTop" value="#808080">
                <span class="color-hex" id="skyColorTopHex">#808080</span>
            </div>
            <div class="color-input">
                <label>Sky Horizon</label>
                <input type="color" id="skyColorHorizon" value="#a0a0a0">
                <span class="color-hex" id="skyColorHorizonHex">#a0a0a0</span>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="showWireframe">
                <label for="showWireframe">Show Gravity Wireframe</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="animateClouds" checked>
                <label for="animateClouds">Animate Clouds</label>
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="header">
            <h1>Gravity-Aware Atmospheric Shaders</h1>
            <div class="header-controls">
                <button class="export-btn" onclick="exportShaderConfig()">Export Shader Config</button>
            </div>
        </div>

        <div id="viewport-container">
            <div class="viewport-panel" data-scene="sphere-surface">
                <div class="viewport-header">
                    <div class="viewport-title">Sphere World - Surface View</div>
                    <div class="viewport-info">Standing on sphere, looking at skybox</div>
                </div>
                <canvas class="viewport-canvas" id="canvas-sphere-surface"></canvas>
            </div>

            <div class="viewport-panel" data-scene="sphere-space">
                <div class="viewport-header">
                    <div class="viewport-title">Sphere World - Space View</div>
                    <div class="viewport-info">Volumetric clouds wrapping sphere</div>
                </div>
                <canvas class="viewport-canvas" id="canvas-sphere-space"></canvas>
            </div>

            <div class="viewport-panel" data-scene="torus-surface">
                <div class="viewport-header">
                    <div class="viewport-title">
                        Torus World - Surface View
                        <button class="export-btn" id="toggleTorusLocation" style="margin-left: 10px; font-size: 10px; padding: 4px 8px;">Toggle Location</button>
                    </div>
                    <div class="viewport-info">Standing on ring outer surface (Halo-style)</div>
                </div>
                <canvas class="viewport-canvas" id="canvas-torus-surface"></canvas>
            </div>

            <div class="viewport-panel" data-scene="torus-space">
                <div class="viewport-header">
                    <div class="viewport-title">Torus World - Space View</div>
                    <div class="viewport-info">Volumetric clouds wrapping torus</div>
                </div>
                <canvas class="viewport-canvas" id="canvas-torus-space"></canvas>
            </div>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Current LOD selection
        let currentLOD = 0;

        // LOD configurations
        const lodConfigs = [
            { name: 'Ultra', raySteps: 128, octaves: 5, shadowSamples: 8, minStep: 0.5, maxStep: 4.0 },
            { name: 'High', raySteps: 48, octaves: 4, shadowSamples: 4, minStep: 1.0, maxStep: 8.0 },
            { name: 'Medium', raySteps: 24, octaves: 3, shadowSamples: 2, minStep: 2.0, maxStep: 16.0 },
            { name: 'Low', raySteps: 12, octaves: 2, shadowSamples: 0, minStep: 4.0, maxStep: 32.0 }
        ];

        // Atmospheric state
        const atmosphereState = {
            // Gravity
            sphereRadius: 1000,
            torusMajor: 1000,
            torusMinor: 100, // Thinner for ringworld appearance
            cloudHeight: 5.0,  // Percentage of radius (5% for better visibility)
            // Clouds
            cloudCoverage: 0.6,
            cloudScale: 1.0,
            cloudDensity: 1.5,
            cloudTranslucency: 0.5, // How much light passes through clouds
            cloudBrightness: 1.0,   // Overall cloud brightness multiplier
            windSpeed: 0.3,
            // Weather Systems
            stormClustering: 0.5,
            stormIntensity: 0.3,
            verticalDev: 0.4,
            godRays: 0.5,
            cloudDetail: 1.0,
            // Star System (Emergent)
            sunDistance: 1.0,  // AU (astronomical units)
            sunRadius: 1.0,    // Solar radii
            sunTemp: 5778,     // Kelvin (sun-like)
            sunAngle: 45,
            // Atmosphere
            skyColorTop: new THREE.Color(0x808080),  // Gray for testing
            skyColorHorizon: new THREE.Color(0xa0a0a0),  // Light gray for testing
            // Display
            showWireframe: false,
            animateClouds: true
        };

        // Scene storage
        const scenes = {};
        const clock = new THREE.Clock();

        // Shader functions
        function getVertexShader() {
            return `
                varying vec3 vWorldPos;
                varying vec3 vNormal;
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    vec4 worldPos = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPos.xyz;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
        }

        function getPlanetShader(sceneType) {
            const isTorus = sceneType.includes('torus');

            return `
                precision highp float;

                uniform vec3 sunDirection;
                uniform vec3 sunColor;
                uniform float sunDistance; // AU
                uniform float time;

                // Gravity params
                uniform float sphereRadius;
                uniform float torusMajor;
                uniform float torusMinor;

                // Cloud params for shadow casting
                uniform float cloudCoverage;
                uniform float cloudScale;
                uniform float cloudDensity;
                uniform float windSpeed;
                uniform float cloudHeight;

                varying vec3 vWorldPos;
                varying vec3 vNormal;
                varying vec2 vUv;

                void main() {
                    vec3 normal = normalize(vNormal);

                    // Sun as point light source
                    vec3 sunPos = sunDirection * sunDistance * 149597870.7;
                    vec3 toSun = normalize(sunPos - vWorldPos);

                    // Lambert diffuse
                    float NdotL = dot(normal, toSun);
                    float diffuse = max(0.0, NdotL);

                    // Surface colors
                    vec3 dayColor = vec3(0.2, 0.5, 0.3); // Lit surface
                    vec3 nightColor = vec3(0.01, 0.01, 0.02); // Dark side

                    // Day/night terminator
                    float terminator = smoothstep(-0.05, 0.05, NdotL);
                    vec3 baseColor = mix(nightColor, dayColor, terminator);

                    // Apply diffuse lighting (cloud shadows handled by atmosphere layer)
                    vec3 litColor = baseColor * (0.1 + diffuse * 0.9);

                    // Subsurface scattering at terminator
                    float sss = pow(max(0.0, -NdotL + 0.3), 2.0) * 0.3;
                    vec3 sssColor = vec3(1.0, 0.5, 0.2) * sss;

                    vec3 finalColor = litColor + sssColor;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;
        }

        function getNoiseFunction() {
            return `
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }
            `;
        }

        function getAtmosphericScatteringShader(sceneType) {
            const isTorus = sceneType.includes('torus');

            return `
                precision highp float;

                uniform vec3 sunDirection;
                uniform vec3 sunColor;
                uniform float sunDistance;
                uniform float time;

                uniform float sphereRadius;
                uniform float torusMajor;
                uniform float torusMinor;
                uniform float cloudHeight;
                uniform float cloudCoverage;
                uniform float cloudScale;
                uniform float cloudDensity;
                uniform float cloudTranslucency;
                uniform float cloudBrightness;
                uniform float windSpeed;
                uniform float stormClustering;
                uniform float stormIntensity;
                uniform float verticalDev;
                uniform float godRays;
                uniform float cloudDetail;

                varying vec3 vWorldPos;
                varying vec3 vNormal;
                varying vec2 vUv;

                ${getNoiseFunction()}

                const vec3 rayleighCoeff = vec3(5.8e-6, 13.5e-6, 33.1e-6);
                const float mieCoeff = 2e-5;

                float rayleighPhase(float cosTheta) {
                    return (3.0 / (16.0 * 3.14159)) * (1.0 + cosTheta * cosTheta);
                }

                float miePhase(float cosTheta, float g) {
                    float g2 = g * g;
                    float a = (1.0 - g2);
                    float b = (2.0 + g2);
                    float c = max(0.01, 1.0 + g2 - 2.0 * g * cosTheta); // Prevent division by zero
                    return (3.0 / (8.0 * 3.14159)) * (a / b) * (1.0 + cosTheta * cosTheta) / pow(c, 1.5);
                }

                // Simple hash for stable dithering
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                // Volumetric cloud sampling
                float sampleCloudDensity(vec3 pos) {
                    ${isTorus ? `
                        vec2 xz = pos.xz;
                        float u = atan(pos.z, pos.x);
                        float distFromMajorAxis = length(xz);
                        float localX = distFromMajorAxis - torusMajor;
                        float v = atan(pos.y, localX);
                        vec2 windOffset = vec2(windSpeed * time * 0.01, 0.0);
                        vec2 uv = vec2(u, v) * cloudScale * 0.5 + windOffset;
                        vec3 samplePos = vec3(uv, 0.0);
                    ` : `
                        float theta = atan(pos.z, pos.x);
                        float phi = asin(pos.y / length(pos));
                        vec2 windOffset = vec2(windSpeed * time * 0.01, 0.0);
                        vec2 uv = vec2(theta, phi) * cloudScale * 0.5 + windOffset;
                        vec3 samplePos = vec3(uv, 0.0);
                    `}
                    float noise = snoise(samplePos) * 0.5 + 0.5;
                    float cloudPresence = smoothstep(0.5 - cloudCoverage * 0.5, 0.5 + cloudCoverage * 0.2, noise);
                    return max(0.0, cloudPresence * cloudDensity * 0.1);
                }

                void main() {
                    vec3 normal = normalize(vNormal);
                    vec3 viewDir = normalize(vWorldPos - cameraPosition);

                    // Calculate view angle - FLIP for backside rendering
                    float viewDotNormal = dot(viewDir, normal);

                    // For BackSide rendering, we're inside looking out
                    // Negative dot means we're looking at the surface properly
                    // Positive/zero means grazing angle - DISCARD IT
                    if(viewDotNormal >= 0.0) {
                        discard;
                    }

                    // Atmosphere depth from viewing angle
                    float atmosphereDepth = abs(viewDotNormal);
                    atmosphereDepth = pow(atmosphereDepth, 1.2);

                    vec3 sunPos = sunDirection * sunDistance * 149597870.7;
                    vec3 toSun = normalize(sunPos - vWorldPos);
                    float cosTheta = dot(viewDir, toSun);

                    vec3 rayleigh = rayleighCoeff * rayleighPhase(cosTheta) * atmosphereDepth;
                    float mie = mieCoeff * miePhase(cosTheta, 0.76) * atmosphereDepth;
                    float sunVisible = max(0.0, dot(normal, toSun));
                    vec3 scatterColor = (rayleigh + vec3(mie)) * sunColor * sunVisible * 10.0;

                    float alpha = atmosphereDepth * 0.3;

                    // VOLUMETRIC CLOUDS - pure ray march, no geometry
                    float baseRadius = ${isTorus ? 'torusMinor' : 'sphereRadius'};
                    // Cloud layer is ABOVE the surface (distance from surface)
                    // cloudHeight is a percentage, so 5% of radius = 0.05 * radius

                    // === TARGETED CHANGE START ===
                    // Center the cloud band around baseRadius * cloudHeight*0.01 and make it span ±50%,
                    // so a 5% height becomes a band from 2.5 to 7.5 for torusMinor=100.
                    float cloudCenter = baseRadius * cloudHeight * 0.01;
                    float halfThickness = cloudCenter * 0.5;
                    float cloudLayerStart = cloudCenter - halfThickness;
                    float cloudLayerEnd = cloudCenter + halfThickness;
                    // === TARGETED CHANGE END ===

                    vec3 rayDir = normalize(vWorldPos - cameraPosition);
                    float dist = length(vWorldPos - cameraPosition);

                    vec3 cloudColor = vec3(0.0);
                    float cloudAlpha = 0.0;

                    // Only raymarch if we're looking through atmosphere shell (not at edges)
                    if(atmosphereDepth > 0.05) {
                        // Add dithering to hide banding artifacts
                        float dither = hash(gl_FragCoord.xy) * 0.125; // 1/8 step offset

                        for(int i = 0; i < 8; i++) {
                            float t = (float(i) + dither) / 8.0;
                            vec3 samplePos = cameraPosition + rayDir * dist * t;

                            ${isTorus ? `
                            // For torus: distance from surface (0 at surface, positive outward)
                            vec2 xz = samplePos.xz;
                            float distFromAxis = length(xz);
                            vec2 q = vec2(distFromAxis - torusMajor, samplePos.y);
                            float distFromTubeSurface = length(q) - torusMinor; // Signed distance: 0 at surface
                            ` : `
                            // For sphere: distance from surface (0 at surface, positive outward)
                            float distFromCenter = length(samplePos) - sphereRadius;
                            `}

                            float sampleRadius = ${isTorus ? 'distFromTubeSurface' : 'distFromCenter'};

                            if(sampleRadius >= cloudLayerStart && sampleRadius <= cloudLayerEnd) {
                                float density = sampleCloudDensity(samplePos);
                                if(density > 0.01) {
                                    vec3 litColor = sunColor * sunVisible * cloudBrightness;
                                    cloudColor += litColor * density * (1.0 - cloudAlpha) * 0.3;
                                    cloudAlpha += density * 0.3 * (1.0 - cloudAlpha);
                                }
                            }
                        }
                    }

                    vec3 finalColor = scatterColor + cloudColor;
                    float finalAlpha = clamp(alpha + cloudAlpha * 0.5, 0.0, 1.0);

                    gl_FragColor = vec4(finalColor, finalAlpha);
                }
            `;
        }

        function getVolumetricCloudShader(sceneType, lodIndex) {
            const config = lodConfigs[lodIndex];
            const isTorus = sceneType.includes('torus');

            // This shader does ACTUAL 3D volumetric ray marching
            return `
                precision highp float;

                uniform float time;
                uniform vec3 sunDirection;
                uniform mat4 cameraWorldMatrix;
                uniform mat4 projectionMatrixInverse;

                // Star System uniforms (Emergent Properties)
                uniform float sunDistance;    // Distance in AU
                uniform float sunRadius;      // Solar radii
                uniform float sunTemp;        // Kelvin
                uniform vec3 sunColor;        // Calculated from temperature

                // Gravity uniforms
                uniform float sphereRadius;
                uniform float torusMajor;
                uniform float torusMinor;
                uniform float cloudHeight;

                // Cloud uniforms
                uniform float cloudCoverage;
                uniform float cloudScale;
                uniform float cloudDensity;
                uniform float cloudTranslucency;
                uniform float cloudBrightness;
                uniform float windSpeed;

                // Weather system uniforms
                uniform float stormClustering;
                uniform float stormIntensity;
                uniform float verticalDev;
                uniform float godRays;
                uniform float cloudDetail;

                // Atmosphere uniforms
                uniform vec3 skyColorTop;
                uniform vec3 skyColorHorizon;

                varying vec3 vWorldPos;
                varying vec3 vNormal;
                varying vec2 vUv;

                const int MAX_STEPS = ${config.raySteps};
                const int OCTAVES = ${config.octaves};
                const float MIN_STEP = ${config.minStep.toFixed(1)};
                const float MAX_STEP = ${config.maxStep.toFixed(1)};

                // Simplex noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                float fbm(vec3 p, int octaves) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for (int i = 0; i < 8; i++) {
                        if (i >= octaves) break;
                        value += amplitude * snoise(p);
                        p *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }

                // Get distance from gravity center based on world type
                float getDistanceFromGravityCenter(vec3 pos) {
                    ${isTorus ?
                        '// Proper torus SDF - UPRIGHT orientation (Halo-style)\n' +
                        '    // Torus stands vertically in XZ plane\n' +
                        '    vec2 q = vec2(length(pos.xz) - torusMajor, pos.y);\n' +
                        '    return length(q) - torusMinor;'
                    :
                        '// Sphere: distance from center minus radius\n' +
                        '    // Center is at origin (0,0,0)\n' +
                        '    return length(pos) - sphereRadius;'
                    }
                }

                // Check if position is inside or outside the torus ring
                bool isInsideRing(vec3 pos) {
                    ${isTorus ?
                        'vec2 xz = pos.xz;\n' +
                        '    float distFromAxis = length(xz);\n' +
                        '    return distFromAxis < torusMajor;'
                    :
                        'return false; // Not applicable for spheres'
                    }
                }

                // Sample cloud density with weather systems
                float sampleCloudDensity(vec3 pos) {
                    ${isTorus ? `
                        vec2 xz = pos.xz;
                        float u = atan(pos.z, pos.x);
                        float distFromMajorAxis = length(xz);
                        float localX = distFromMajorAxis - torusMajor;
                        float v = atan(pos.y, localX);
                        vec2 windOffset = vec2(windSpeed * time * 0.01, 0.0);
                        vec2 uv = vec2(u, v) * cloudScale * 0.5 + windOffset;
                        vec3 samplePos = vec3(uv, 0.0);
                    ` : `
                        float theta = atan(pos.z, pos.x);
                        float phi = asin(pos.y / length(pos));
                        vec2 windOffset = vec2(windSpeed * time * 0.01, 0.0);
                        vec2 uv = vec2(theta, phi) * cloudScale * 0.5 + windOffset;
                        vec3 samplePos = vec3(uv, 0.0);
                    `}

                    // Base cloud pattern
                    float noise = fbm(samplePos, OCTAVES);
                    noise = noise * 0.5 + 0.5;

                    // Base cloud presence (coverage threshold)
                    float cloudPresence = smoothstep(0.5 - cloudCoverage * 0.5, 0.5 + cloudCoverage * 0.2, noise);

                    // Storm clustering creates REGIONS of higher density
                    float stormDensityBoost = 1.0;
                    float isInStorm = 0.0;
                    vec3 cellFract = vec3(0.5);
                    float minDist = 1.0;

                    if (cloudDetail > 0.1 && stormClustering > 0.1) {
                        // Large-scale storm cell grid
                        vec3 stormPos = samplePos * (0.3 + stormClustering * 0.5);
                        vec3 cellId = floor(stormPos);
                        cellFract = fract(stormPos);

                        // Check nearest cells for storm centers
                        minDist = 10.0;
                        for(int i = 0; i < 3; i++) {
                            vec3 neighbor = cellId + vec3(float(i - 1), 0.0, 0.0);
                            vec3 center = vec3(
                                snoise(neighbor * 10.0),
                                0.5,
                                snoise(neighbor * 10.0 + vec3(200.0))
                            ) * 0.5 + 0.5;
                            vec3 toCenter = center + vec3(float(i - 1), 0.0, 0.0) - cellFract;
                            float dist = length(toCenter);
                            minDist = min(minDist, dist);
                        }

                        // Storm cells have 2-3x density boost
                        isInStorm = 1.0 - smoothstep(0.2, 0.6, minDist);
                        stormDensityBoost = mix(1.0, 2.5, isInStorm * stormClustering);
                    }

                    // Storm intensity adds extra density to storm regions
                    float stormExtraDensity = 0.0;
                    if (stormIntensity > 0.1 && isInStorm > 0.5) {
                        stormExtraDensity = stormIntensity * 0.3;
                    }

                    // Storm cells are just denser regions, no eye clearing

                    // Vertical development - taller clouds in storms
                    float height = pos.y * 0.001;
                    float verticalExtent = 1.0;
                    if(verticalDev > 0.1 && isInStorm > 0.3) {
                        // Storm clouds reach higher
                        float heightFalloff = 1.0 - abs(height - 0.5) * 2.0;
                        verticalExtent = 1.0 + verticalDev * isInStorm * heightFalloff * 0.5;
                    }

                    // Combine all factors
                    cloudPresence *= stormDensityBoost; // Storm regions are denser
                    cloudPresence *= verticalExtent; // Storms extend vertically
                    cloudPresence += stormExtraDensity; // Extra density in storms

                    // Add detail noise only if detail level is high enough
                    if (cloudDetail > 0.5) {
                        float detail = snoise(samplePos * 2.0) * 0.15 * cloudDetail;
                        cloudPresence += detail * cloudPresence;
                    }

                    // Final density
                    float density = cloudPresence * cloudDensity * 0.1;

                    return max(0.0, density);
                }

                // Calculate emergent sun properties
                float getSunIntensity() {
                    // Inverse square law for light intensity
                    float distanceAttenuation = 1.0 / (sunDistance * sunDistance);

                    // Stefan-Boltzmann law for luminosity (simplified)
                    float tempRatio = sunTemp / 5778.0; // Relative to our sun
                    float luminosity = tempRatio * tempRatio * tempRatio * tempRatio;

                    // Size contribution
                    float sizeRatio = sunRadius * sunRadius;

                    return distanceAttenuation * luminosity * sizeRatio;
                }

                float getSunApparentSize() {
                    // Angular diameter based on distance and radius
                    // Sun's angular size at 1 AU = 0.533 degrees
                    return (sunRadius / sunDistance) * 0.533;
                }

                // Calculate atmospheric ambient based on sun and scattering
                vec3 getAtmosphericAmbient(float sunIntensity) {
                    // Just gray ambient, NO BLUE
                    return vec3(0.2, 0.2, 0.2);
                }

                // Calculate light reaching a point in the cloud (self-shadowing)
                float calculateLightTransmission(vec3 pos) {
                    float transmission = 1.0;
                    float shadowStepSize = 10.0;
                    float shadowDist = 0.0;

                    // March toward sun to calculate shadows
                    for (int i = 0; i < 16; i++) {
                        vec3 shadowPos = pos + sunDirection * shadowDist;
                        float shadowDensity = sampleCloudDensity(shadowPos);
                        transmission *= exp(-shadowDensity * shadowStepSize * 0.5);
                        shadowDist += shadowStepSize;
                        if (transmission < 0.01) break;
                    }

                    return transmission;
                }

                // Rayleigh scattering phase function (wavelength-dependent)
                float rayleighPhase(float cosTheta) {
                    return (3.0 / (16.0 * 3.14159)) * (1.0 + cosTheta * cosTheta);
                }

                // Mie scattering phase function (forward scattering for water droplets)
                float miePhase(float cosTheta, float g) {
                    float g2 = g * g;
                    float nom = (1.0 - g2);
                    float denom = pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5);
                    return (3.0 / (8.0 * 3.14159)) * nom / denom;
                }

                // Simplified ray march with atmospheric lighting
                vec4 marchClouds(vec3 ro, vec3 rd, float maxDist) {
                    vec3 color = vec3(0.0);
                    float transmittance = 1.0;

                    // FEWER STEPS for performance
                    int steps = MAX_STEPS / 4; // Quarter the steps
                    float stepSize = maxDist / float(steps);
                    float dist = 0.0;

                    // Sun as point light source
                    vec3 sunPos = sunDirection * sunDistance * 149597870.7; // AU to km

                    // Calculate if we're on day or night side of planet
                    ${isTorus ?
                        'vec3 planetCenter = vec3(torusMajor, 0.0, 0.0); // Approximate'
                        :
                        'vec3 planetCenter = vec3(0.0, 0.0, 0.0);'
                    }
                    vec3 toPlanetCenter = normalize(planetCenter - ro);
                    vec3 toSun = normalize(sunPos - planetCenter);
                    float daySide = max(0.0, dot(-toPlanetCenter, toSun)); // Are we on lit side?

                    // Rayleigh scattering coefficients (wavelength-dependent, shorter wavelengths scatter more)
                    vec3 rayleighCoeff = vec3(5.8, 13.5, 33.1) * 0.00001; // R, G, B

                    // God ray accumulation
                    vec3 godRayColor = vec3(0.0);
                    float prevDensity = 0.0;

                    for (int i = 0; i < 128; i++) {
                        if (i >= steps) break;
                        if (transmittance < 0.01) break;

                        vec3 pos = ro + rd * dist;
                        float density = sampleCloudDensity(pos);

                        if (density > 0.01) {
                            // Calculate light direction from this point to sun
                            vec3 lightDir = normalize(sunPos - pos);

                            // PROPER shadow sampling - march through cloud toward sun
                            float shadowSteps = 4.0;
                            float shadowDist = 0.0;
                            float shadowAccum = 0.0;

                            for(int s = 0; s < 4; s++) {
                                shadowDist += 0.3;
                                vec3 shadowPos = pos + lightDir * shadowDist;
                                shadowAccum += sampleCloudDensity(shadowPos);
                            }

                            // Light attenuation through cloud shadows
                            float lightAtten = exp(-shadowAccum * 1.5);

                            // Phase functions for scattering
                            float cosTheta = dot(rd, lightDir);
                            float rayleighPhaseVal = rayleighPhase(cosTheta);
                            float miePhaseVal = miePhase(cosTheta, 0.76); // Forward scattering

                            // Chromatic scattering at cloud edges (Rayleigh dominates at thin edges)
                            float edgeFactor = smoothstep(0.3, 0.05, density); // Thin = edge

                            // Rayleigh scattering (wavelength-dependent, creates orange/red at edges)
                            vec3 rayleighScatter = rayleighCoeff * rayleighPhaseVal * edgeFactor * 50.0;

                            // Mie scattering (from water droplets, less wavelength-dependent)
                            vec3 mieScatter = vec3(1.0) * miePhaseVal * 0.02;

                            // Sun angle determines color temperature
                            float sunAngle = dot(lightDir, vec3(0.0, 1.0, 0.0));
                            float sunsetFactor = smoothstep(-0.2, 0.3, sunAngle);

                            // Sun color shifts orange at low angles (more atmosphere to pass through)
                            vec3 sunColor = mix(vec3(1.0, 0.5, 0.2), vec3(1.0, 0.98, 0.95), sunsetFactor);

                            // Direct sunlight contribution with chromatic aberration
                            vec3 directLight = sunColor * lightAtten * (1.0 + rayleighScatter + mieScatter);

                            // Ambient sky light (blue Rayleigh scattering from atmosphere above)
                            vec3 ambientSkyColor = vec3(0.4, 0.5, 0.6);
                            vec3 ambientLight = ambientSkyColor * 0.5;

                            // Shadow color (blue-shifted from lack of direct sun)
                            vec3 shadowColor = vec3(0.3, 0.35, 0.4);

                            // Combine direct and ambient
                            vec3 cloudColor = directLight + ambientLight;

                            // In shadow areas, use shadow color
                            cloudColor = mix(shadowColor, cloudColor, lightAtten * 0.7 + 0.3);

                            // Global day/night modulation
                            float globalLight = 0.15 + daySide * 0.85;
                            cloudColor *= globalLight;

                            // Apply brightness multiplier
                            cloudColor *= cloudBrightness;

                            // Proper Beer's law absorption with translucency
                            // Translucency reduces absorption (more light passes through)
                            float absorption = density * stepSize * (1.0 - cloudTranslucency * 0.5);
                            float sampleTransmittance = exp(-absorption);
                            float scatterAmount = (1.0 - sampleTransmittance);

                            // Accumulate - clouds scatter light, reducing transmittance
                            color += cloudColor * scatterAmount * transmittance;
                            transmittance *= sampleTransmittance;

                            // God rays at cloud edges with chromatic aberration
                            if (godRays > 0.01 && i > 0) {
                                // Detect density gradient (cloud edges)
                                float densityGradient = abs(density - prevDensity);

                                // More rays where sun is aligned with view
                                float sunAlignment = max(0.0, dot(rd, lightDir));

                                // Only create rays at significant edges with good sun alignment
                                if (densityGradient > 0.1 && sunAlignment > 0.5) {
                                    // Ray intensity based on edge sharpness and sun angle
                                    float rayStrength = densityGradient * sunAlignment * godRays * lightAtten;

                                    // RayColor computation
                                    vec3 rayColor = sunColor * daySide;
                                    rayColor += rayleighScatter * sunColor * 0.5;

                                    godRayColor += rayColor * rayStrength * transmittance * 0.05;
                                }
                            }
                        } else if (godRays > 0.01 && prevDensity > 0.1) {
                            // Exiting cloud - strong god ray at edge
                            vec3 lightDir2 = normalize(sunPos - pos);
                            float sunAlignment = max(0.0, dot(rd, lightDir2));
                            if (sunAlignment > 0.5) {
                                // Chromatic edge glow
                                float cosTheta = dot(rd, lightDir2);
                                float rayleighPhaseVal = rayleighPhase(cosTheta);
                                vec3 edgeGlow = rayleighCoeff * rayleighPhaseVal * 100.0;

                                float sunAngle = dot(lightDir2, vec3(0.0, 1.0, 0.0));
                                float sunsetFactor = smoothstep(-0.2, 0.3, sunAngle);
                                vec3 sunColor = mix(vec3(1.0, 0.5, 0.2), vec3(1.0, 0.98, 0.95), sunsetFactor);

                                float exitRay = prevDensity * sunAlignment * godRays;
                                vec3 rayColor = (sunColor + edgeGlow) * daySide;
                                godRayColor += rayColor * exitRay * transmittance * 0.08;
                            }
                        }

                        prevDensity = density;
                        dist += stepSize;
                    }

                    // Combine cloud color with god rays
                    color += godRayColor;

                    float alpha = 1.0 - transmittance;
                    return vec4(color, alpha);
                }

                void main() {
                    // Ray marching setup
                    vec3 rayOrigin = vWorldPos;
                    vec3 rayDir = normalize(vWorldPos - cameraPosition);

                    // Cloud layer thickness based on cloudHeight parameter
                    float baseRadius = ${isTorus ? 'torusMinor' : 'sphereRadius'};
                    float cloudThickness = baseRadius * cloudHeight * 0.01; // cloudHeight is percentage

                    // March ONLY through the cloud layer (from surface upward, not into planet)
                    // The cloud shell geometry is already positioned above the surface
                    vec4 clouds = marchClouds(rayOrigin, rayDir, cloudThickness);

                    // No background - we're rendering the clouds themselves
                    gl_FragColor = vec4(clouds.rgb, clouds.a);
                }
            `;
        }

        // Calculate sun color from temperature using blackbody radiation
        function getSunColorFromTemp(tempKelvin) {
            // Simplified blackbody radiation color calculation
            let r, g, b;

            // Red
            if (tempKelvin >= 6600) {
                r = 1.0;
            } else {
                r = tempKelvin / 100;
                r = 329.698727446 * Math.pow(r - 60, -0.1332047592);
                r = Math.max(0, Math.min(255, r)) / 255;
            }

            // Green
            if (tempKelvin <= 6600) {
                g = tempKelvin / 100;
                g = 99.4708025861 * Math.log(g) - 161.1195681661;
            } else {
                g = tempKelvin / 100;
                g = 288.1221695283 * Math.pow(g - 60, -0.0755148492);
            }
            g = Math.max(0, Math.min(255, g)) / 255;

            // Blue
            if (tempKelvin >= 6600) {
                b = 1.0;
            } else if (tempKelvin <= 1900) {
                b = 0;
            } else {
                b = tempKelvin / 100 - 10;
                b = 138.5177312231 * Math.log(b) - 305.0447927307;
                b = Math.max(0, Math.min(255, b)) / 255;
            }

            return new THREE.Color(r, g, b);
        }

        // Initialize scene
        function initScene(canvasId, sceneType) {
            const canvas = document.getElementById(canvasId);
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                60,
                canvas.clientWidth / canvas.clientHeight,
                0.1,
                10000
            );

            const controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Geometry setup
            let planetGeometry, atmosphereGeometry, cloudGeometry;

            if (sceneType.includes('torus')) {
                const segments = 128; // Higher res to reduce seams
                planetGeometry = new THREE.TorusGeometry(
                    atmosphereState.torusMajor,
                    atmosphereState.torusMinor,
                    64, segments
                );
                atmosphereGeometry = new THREE.TorusGeometry(
                    atmosphereState.torusMajor,
                    atmosphereState.torusMinor * 1.05,
                    64, segments
                );
                const cloudOffset = atmosphereState.torusMinor * atmosphereState.cloudHeight * 0.01;
                cloudGeometry = new THREE.TorusGeometry(
                    atmosphereState.torusMajor,
                    atmosphereState.torusMinor + cloudOffset,
                    64, segments
                );
            } else {
                planetGeometry = new THREE.SphereGeometry(
                    atmosphereState.sphereRadius,
                    128, 128 // Higher res to reduce seams
                );
                atmosphereGeometry = new THREE.SphereGeometry(
                    atmosphereState.sphereRadius * 1.05,
                    128, 128
                );
                const cloudStart = 1.0 + (atmosphereState.cloudHeight * 0.01);
                cloudGeometry = new THREE.SphereGeometry(
                    atmosphereState.sphereRadius * cloudStart,
                    128, 128
                );
            }

            // Planet surface material
            const planetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0.0).normalize() },
                    sunColor: { value: getSunColorFromTemp(atmosphereState.sunTemp) },
                    sunDistance: { value: atmosphereState.sunDistance },
                    sphereRadius: { value: atmosphereState.sphereRadius },
                    torusMajor: { value: atmosphereState.torusMajor },
                    torusMinor: { value: atmosphereState.torusMinor },
                    cloudCoverage: { value: atmosphereState.cloudCoverage },
                    cloudScale: { value: atmosphereState.cloudScale },
                    cloudDensity: { value: atmosphereState.cloudDensity },
                    windSpeed: { value: atmosphereState.windSpeed },
                    cloudHeight: { value: atmosphereState.cloudHeight }
                },
                vertexShader: getVertexShader(),
                fragmentShader: getPlanetShader(sceneType),
                side: THREE.FrontSide
            });

            const planetSurface = new THREE.Mesh(planetGeometry, planetMaterial);
            scene.add(planetSurface);

            // Atmospheric scattering shell
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    sunDirection: { value: new THREE.Vector3(0.5, 0.5, 0.0).normalize() },
                    sunColor: { value: getSunColorFromTemp(atmosphereState.sunTemp) },
                    sunDistance: { value: atmosphereState.sunDistance },
                    sphereRadius: { value: atmosphereState.sphereRadius },
                    torusMajor: { value: atmosphereState.torusMajor },
                    torusMinor: { value: atmosphereState.torusMinor },
                    cloudHeight: { value: atmosphereState.cloudHeight },
                    // Cloud parameters
                    cloudCoverage: { value: atmosphereState.cloudCoverage },
                    cloudScale: { value: atmosphereState.cloudScale },
                    cloudDensity: { value: atmosphereState.cloudDensity },
                    cloudTranslucency: { value: atmosphereState.cloudTranslucency },
                    cloudBrightness: { value: atmosphereState.cloudBrightness },
                    windSpeed: { value: atmosphereState.windSpeed },
                    stormClustering: { value: atmosphereState.stormClustering },
                    stormIntensity: { value: atmosphereState.stormIntensity },
                    verticalDev: { value: atmosphereState.verticalDev },
                    godRays: { value: atmosphereState.godRays },
                    cloudDetail: { value: atmosphereState.cloudDetail }
                },
                vertexShader: getVertexShader(),
                fragmentShader: getAtmosphericScatteringShader(sceneType),
                transparent: true,
                depthWrite: false,
                side: THREE.BackSide, // Render from inside
                blending: THREE.AdditiveBlending
            });

            const atmosphereShell = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphereShell);

            // NO CLOUD GEOMETRY - clouds are purely volumetric from atmosphere shader

            // Reference objects and camera position based on scene type
            let referenceObjects = [];

            if (sceneType === 'sphere-surface') {
                // Standing on sphere surface
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
                block.position.set(0, 0.5, 0);
                scene.add(block);
                referenceObjects.push(block);

                // Ground plane
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(100, 100),
                    new THREE.MeshStandardMaterial({ color: 0x444444 })
                );
                ground.rotation.x = -Math.PI / 2;
                scene.add(ground);
                referenceObjects.push(ground);

                // Lighting
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 10, 5);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x404040));

                camera.position.set(5, 2, 5);
                camera.lookAt(0, 1, 0);

            } else if (sceneType === 'sphere-space') {
                // Viewing sphere from space
                camera.position.set(0, 0, 2000);
                camera.lookAt(0, 0, 0);

                // Add planet surface (always visible in space view)
                const planetSurface = new THREE.Mesh(
                    new THREE.SphereGeometry(atmosphereState.sphereRadius * 0.99, 64, 48),
                    new THREE.MeshStandardMaterial({
                        color: 0x2a4a2a,  // Earth-like green-blue
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                scene.add(planetSurface);
                referenceObjects.push(planetSurface);

                // Add directional light for planet (will be updated with sun angle)
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                const sunRad = atmosphereState.sunAngle * Math.PI / 180;
                sunLight.position.set(Math.cos(sunRad) * 500, Math.sin(sunRad) * 500, 0);
                scene.add(sunLight);
                scene.add(new THREE.AmbientLight(0x202030, 0.5));

                // Store reference for updates
                scene.sunLight = sunLight;

                // Wireframe sphere for reference
                if (atmosphereState.showWireframe) {
                    const sphereWire = new THREE.Mesh(
                        new THREE.SphereGeometry(atmosphereState.sphereRadius, 32, 24),
                        new THREE.MeshBasicMaterial({
                            color: 0x444444,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.3
                        })
                    );
                    scene.add(sphereWire);
                    referenceObjects.push(sphereWire);
                }

            } else if (sceneType === 'torus-surface') {
                // Standing ON the torus ring surface (like Halo ringworld)
                const R = atmosphereState.torusMajor;
                const r = atmosphereState.torusMinor;

                // Track location: outer (0) or inner (Math.PI)
                let torusLocation = 0; // Start on outer edge

                function setupTorusLocation(location) {
                    // Clear old objects
                    referenceObjects.forEach(obj => scene.remove(obj));
                    referenceObjects = [];

                    const u = 0; // Front of the torus
                    const v = location; // 0 = outer edge, PI = inner edge

                    // Calculate actual 3D point on torus surface
                    const surfacePoint = new THREE.Vector3(
                        (R + r * Math.cos(v)) * Math.cos(u),
                        r * Math.sin(v),
                        (R + r * Math.cos(v)) * Math.sin(u)
                    );

                    // Calculate surface normal at this point
                    const centerLinePoint = new THREE.Vector3(
                        R * Math.cos(u),
                        0,
                        R * Math.sin(u)
                    );
                    const normal = new THREE.Vector3().subVectors(surfacePoint, centerLinePoint).normalize();

                    // Calculate tangent vectors for local coordinate system
                    const ringDirection = new THREE.Vector3(-Math.sin(u), 0, Math.cos(u));

                    // Block on the ring surface
                    const block = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1, 1),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    block.position.copy(surfacePoint).addScaledVector(normal, 0.5);
                    scene.add(block);
                    referenceObjects.push(block);

                    // Ground plane tangent to torus surface
                    const ground = new THREE.Mesh(
                        new THREE.PlaneGeometry(200, 200),
                        new THREE.MeshStandardMaterial({
                            color: 0x444444,
                            side: THREE.DoubleSide
                        })
                    );
                    ground.position.copy(surfacePoint);
                    const lookAtPoint = surfacePoint.clone().add(normal);
                    ground.lookAt(lookAtPoint);
                    scene.add(ground);
                    referenceObjects.push(ground);

                    // Visual reference: Show the actual torus ring
                    const torusRef = new THREE.Mesh(
                        new THREE.TorusGeometry(R, r, 48, 96),
                        new THREE.MeshBasicMaterial({
                            color: 0x224466,
                            transparent: true,
                            opacity: 0.15,
                            side: THREE.DoubleSide
                        })
                    );
                    scene.add(torusRef);
                    referenceObjects.push(torusRef);

                    // Add visual indicator for opposite side
                    const oppositeIndicator = new THREE.Mesh(
                        new THREE.BoxGeometry(100, 20, 100),
                        new THREE.MeshBasicMaterial({
                            color: 0x666644,
                            transparent: true,
                            opacity: 0.3
                        })
                    );
                    oppositeIndicator.position.set(-R, 0, 0);
                    scene.add(oppositeIndicator);
                    referenceObjects.push(oppositeIndicator);

                    // Lighting aligned with local surface
                    const light = new THREE.DirectionalLight(0xffffff, 1);
                    light.position.copy(surfacePoint).addScaledVector(normal, 50).addScaledVector(ringDirection, 20);
                    scene.add(light);
                    scene.add(new THREE.AmbientLight(0x404040));

                    // Camera positioned above surface, oriented by gravity
                    const cameraHeight = 2;
                    const cameraBack = 5;

                    // Camera position: slightly above surface
                    camera.position.copy(surfacePoint)
                        .addScaledVector(normal, cameraHeight)
                        .addScaledVector(ringDirection, -cameraBack);

                    // Look target: forward along the ring
                    const lookTarget = surfacePoint.clone()
                        .addScaledVector(normal, 1)
                        .addScaledVector(ringDirection, 10);

                    // CRITICAL: Set camera up vector to align with gravity
                    // The "up" direction for the camera should be the surface normal (anti-gravity)
                    camera.up.copy(normal);

                    camera.lookAt(lookTarget);
                    controls.target.copy(lookTarget);

                    // Update controls to respect the new up vector
                    controls.update();
                }

                // Initial setup on outer edge
                setupTorusLocation(torusLocation);

                // Add toggle button handler
                document.getElementById('toggleTorusLocation').addEventListener('click', () => {
                    torusLocation = torusLocation === 0 ? Math.PI : 0;
                    setupTorusLocation(torusLocation);

                    // Update info text
                    const info = document.querySelector('[data-scene="torus-surface"] .viewport-info');
                    info.textContent = torusLocation === 0
                        ? 'Standing on ring outer surface (Halo-style)'
                        : 'Standing on ring inner surface (looking at opposite side)';
                });

            } else if (sceneType === 'torus-space') {
                // Viewing torus from space
                camera.position.set(1500, 1000, 1500);
                camera.lookAt(0, 0, 0);

                // Add torus surface (always visible in space view)
                const torusSurface = new THREE.Mesh(
                    new THREE.TorusGeometry(
                        atmosphereState.torusMajor * 0.99,
                        atmosphereState.torusMinor * 0.99,
                        64, 128
                    ),
                    new THREE.MeshStandardMaterial({
                        color: 0x3a5a3a,  // Earth-like surface
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                scene.add(torusSurface);
                referenceObjects.push(torusSurface);

                // Add directional light for torus (will be updated with sun angle)
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                const sunRad = atmosphereState.sunAngle * Math.PI / 180;
                sunLight.position.set(Math.cos(sunRad) * 500, Math.sin(sunRad) * 500, 0);
                scene.add(sunLight);
                scene.add(new THREE.AmbientLight(0x202030, 0.5));

                // Store reference for updates
                scene.sunLight = sunLight;

                // Wireframe torus for reference
                if (atmosphereState.showWireframe) {
                    const torusWire = new THREE.Mesh(
                        new THREE.TorusGeometry(
                            atmosphereState.torusMajor,
                            atmosphereState.torusMinor,
                            48, 96
                        ),
                        new THREE.MeshBasicMaterial({
                            color: 0x444444,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.3
                        })
                    );
                    scene.add(torusWire);
                    referenceObjects.push(torusWire);
                }
            }

            // Store scene info for render loop
            scenes[canvasId] = {
                scene,
                camera,
                renderer,
                controls,
                planetMaterial,
                atmosphereMaterial,
                referenceObjects,
                canvas
            };

            return scenes[canvasId];
        }

        // ... (rest of the JS omitted here for brevity in this preview; same as original file's init/animate/update functions)
        // The remainder of the file (UI wiring, render loop, shader updates, export function) is unchanged.

        // Initialize all four views
        const sceneSphereSurface = initScene('canvas-sphere-surface', 'sphere-surface');
        const sceneSphereSpace = initScene('canvas-sphere-space', 'sphere-space');
        const sceneTorusSurface = initScene('canvas-torus-surface', 'torus-surface');
        const sceneTorusSpace = initScene('canvas-torus-space', 'torus-space');

        // Setup rest of UI and animation loop (implementation identical to the uploaded file)
        setupUI();
        updateShadersForLOD();
        animate();
    </script>
</body>
</html>
