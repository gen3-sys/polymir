<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymir - Advanced Planetary Weather System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: monospace;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.5;
            max-width: 320px;
            border: 1px solid #4CAF50;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10,10,15,0.95);
            padding: 15px;
            border-radius: 5px;
            color: white;
            max-height: 90vh;
            overflow-y: auto;
            width: 320px;
            border: 1px solid #4CAF50;
        }
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }
        .control-group {
            margin: 15px 0;
            padding: 12px;
            background: rgba(20,30,40,0.9);
            border-radius: 5px;
            border-left: 3px solid #4CAF50;
        }
        .control-group h4 {
            margin: 0 0 10px 0;
            color: #87CEEB;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 3px;
            margin: 5px 2px;
            font-size: 11px;
            transition: background 0.3s;
        }
        button:hover { background: #45a049; }
        button.danger { background: #f44336; }
        button.danger:hover { background: #da190b; }
        button.secondary { background: #2196F3; }
        button.secondary:hover { background: #0b7dda; }
        input[type="range"] {
            width: 180px;
            vertical-align: middle;
        }
        label {
            display: inline-block;
            width: 130px;
            font-size: 11px;
            color: #aaa;
        }
        .value {
            display: inline-block;
            width: 60px;
            text-align: right;
            color: #4CAF50;
            font-size: 11px;
            font-weight: bold;
        }
        .stats {
            color: #4CAF50;
            margin-top: 5px;
        }
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        .update-flash {
            background: rgba(76, 175, 80, 0.3) !important;
            transition: background 0.5s;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>‚ö° Polymir Weather System</strong><br>
        <div class="stats">
            Distance: <span id="distanceVal">0</span>m<br>
            Sun Angle: <span id="sunAngle">0</span>¬∞<br>
            Cloud Coverage: <span id="cloudCoverage">0</span>%<br>
            Shadow Intensity: <span id="shadowIntensity">0</span>%<br>
            FPS: <span id="fpsVal">0</span>
        </div>
        <br>
        <strong>Controls:</strong><br>
        üñ±Ô∏è Drag: Rotate view (orbital)<br>
        üñ±Ô∏è Wheel: Zoom in/out<br>
        <kbd>F</kbd>: Toggle first-person mode<br>
        <kbd>WASD</kbd>: Move (first-person)<br>
        <kbd>SPACE/SHIFT</kbd>: Up/Down<br>
        <kbd>R</kbd>: Reset to orbital view
    </div>

    <div id="controls">
        <h3>üåç Planetary Weather System</h3>

        <div class="control-group">
            <h4>‚òÄÔ∏è Sun & Time</h4>
            <div>
                <label>Sun Speed:</label>
                <input type="range" id="sunSpeed" min="0" max="0.5" step="0.01" value="0.1">
                <span class="value" id="sunSpeedVal">0.10x</span>
            </div>
            <div>
                <label>Time of Day:</label>
                <input type="range" id="timeOfDay" min="0" max="6.28" step="0.01" value="1.57">
                <span class="value" id="timeOfDayVal">90¬∞</span>
            </div>
            <div style="margin-top: 10px;">
                <button id="toggleSun" class="secondary">‚è∏Ô∏è Pause Sun</button>
            </div>
        </div>

        <div class="control-group">
            <h4>‚òÅÔ∏è Cloud Layers</h4>
            <div style="margin-bottom: 10px;">
                <button id="addCloudLayer" class="secondary">‚ûï Add Layer</button>
                <span style="margin-left: 10px; color: #4CAF50;" id="layerCount">1 layer</span>
            </div>
            <div id="cloudLayersContainer"></div>
        </div>

        <div class="control-group">
            <h4>üå¨Ô∏è Global Cloud Settings</h4>
            <div>
                <label>Cloud Glow:</label>
                <input type="range" id="cloudGlow" min="0" max="3" step="0.1" value="1.5">
                <span class="value" id="cloudGlowVal">1.5x</span>
            </div>
        </div>

        <div class="control-group">
            <h4>üå¨Ô∏è Wind Patterns</h4>
            <div>
                <label>Wind Speed:</label>
                <input type="range" id="windSpeed" min="0" max="0.5" step="0.01" value="0.08">
                <span class="value" id="windSpeedVal">0.08</span>
            </div>
            <div>
                <label>Wind Direction:</label>
                <input type="range" id="windDir" min="0" max="6.28" step="0.1" value="0.785">
                <span class="value" id="windDirVal">45¬∞</span>
            </div>
            <div>
                <label>Wind Curl:</label>
                <input type="range" id="windCurl" min="0" max="2" step="0.1" value="0.4">
                <span class="value" id="windCurlVal">0.4</span>
            </div>
        </div>

        <div class="control-group">
            <h4>üåì Shadows & Lighting</h4>
            <div>
                <label>Shadow Strength:</label>
                <input type="range" id="shadowStrength" min="0" max="1" step="0.05" value="0.7">
                <span class="value" id="shadowStrengthVal">70%</span>
            </div>
            <div>
                <label>Shadow Softness:</label>
                <input type="range" id="shadowSoftness" min="0.1" max="2" step="0.1" value="0.5">
                <span class="value" id="shadowSoftnessVal">0.5</span>
            </div>
            <div>
                <label>Cloud Glow:</label>
                <input type="range" id="cloudGlow" min="0" max="3" step="0.1" value="1.5">
                <span class="value" id="cloudGlowVal">1.5x</span>
            </div>
        </div>

        <div class="control-group">
            <h4>üåå Aurora Atmosphere</h4>
            <div>
                <label>Aurora Intensity:</label>
                <input type="range" id="auroraIntensity" min="0" max="1" step="0.05" value="0.4">
                <span class="value" id="auroraIntensityVal">40%</span>
            </div>
            <div>
                <label>Aurora Speed:</label>
                <input type="range" id="auroraSpeed" min="0" max="2" step="0.1" value="0.5">
                <span class="value" id="auroraSpeedVal">0.5x</span>
            </div>
        </div>

        <div class="control-group">
            <h4>üé® Weather Presets</h4>
            <div class="preset-buttons">
                <button id="presetClear">‚òÄÔ∏è Clear</button>
                <button id="presetPartly">‚õÖ Partly Cloudy</button>
                <button id="presetOvercast">‚òÅÔ∏è Overcast</button>
                <button id="presetStormy">‚õàÔ∏è Stormy</button>
                <button id="presetHeavy">üåßÔ∏è Heavy</button>
                <button id="presetWispy">üå§Ô∏è Wispy</button>
            </div>
        </div>

        <div class="control-group">
            <h4>üéÆ Camera</h4>
            <div class="preset-buttons">
                <button id="viewOrbit">Orbital</button>
                <button id="viewClose">Close</button>
                <button id="viewSurface">Surface</button>
                <button id="viewVoxels">üß± Voxels</button>
                <button id="viewReset">Reset</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // ===== VOXEL CHUNK SYSTEM =====
        class VoxelChunk {
            constructor(chunkX, chunkY, chunkZ, chunkSize = 16) {
                this.chunkX = chunkX;
                this.chunkY = chunkY;
                this.chunkZ = chunkZ;
                this.chunkSize = chunkSize;
                this.voxels = {}; // Sparse: 'x,y,z' -> {type, color}
                this.mesh = null;
                this.dirty = true;
            }

            key(x, y, z) {
                return `${x},${y},${z}`;
            }

            setVoxel(x, y, z, type, color) {
                if (type === 0 || type === null) {
                    delete this.voxels[this.key(x, y, z)];
                } else {
                    this.voxels[this.key(x, y, z)] = { type, color };
                }
                this.dirty = true;
            }

            getVoxel(x, y, z) {
                return this.voxels[this.key(x, y, z)];
            }

            // Generate voxels from heightmap at this chunk position
            generateFromHeightmap(heightFunc, planetSurface) {
                const startX = this.chunkX * this.chunkSize;
                const startY = this.chunkY * this.chunkSize;
                const startZ = this.chunkZ * this.chunkSize;

                let voxelCount = 0;

                for (let x = 0; x < this.chunkSize; x++) {
                    for (let z = 0; z < this.chunkSize; z++) {
                        const worldX = startX + x;
                        const worldZ = startZ + z;

                        // Sample height from planet surface
                        const height = heightFunc(worldX, worldZ, planetSurface);
                        const heightVoxels = Math.floor(height);

                        for (let y = 0; y < this.chunkSize; y++) {
                            const worldY = startY + y;

                            if (worldY <= heightVoxels) {
                                // Use EXACT same color logic as planet shader
                                let color;
                                const h = worldY; // Actual height value for this voxel

                                if (h < -5) {
                                    // Deep ocean
                                    color = 0x2269B0; // vec3(0.13, 0.43, 0.69)
                                } else if (h < 0) {
                                    // Shallow water
                                    color = 0x4D96C7; // Lerp between deep and shallow
                                } else if (h < 2) {
                                    // Beach/shore
                                    color = 0xC2B380; // vec3(0.76, 0.70, 0.50)
                                } else if (h < 10) {
                                    // Grassland
                                    color = 0x4D9A4D; // vec3(0.30, 0.60, 0.30)
                                } else if (h < 18) {
                                    // Forest/hills - darker green
                                    color = 0x3D833D; // vec3(0.24, 0.51, 0.24)
                                } else if (h < 25) {
                                    // Mountains - rocky brown/gray
                                    color = 0x786358; // vec3(0.47, 0.39, 0.35)
                                } else {
                                    // Snow peaks
                                    color = 0xF0F0FA; // vec3(0.94, 0.94, 0.98)
                                }

                                this.setVoxel(x, y, z, 1, color);
                                voxelCount++;
                            }
                        }
                    }
                }

                console.log(`Chunk [${this.chunkX},${this.chunkY},${this.chunkZ}] generated ${voxelCount} voxels`);
            }

            // Build optimized mesh using instanced rendering
            buildMesh() {
                if (!this.dirty) return this.mesh;

                // Remove old mesh
                if (this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.mesh = null;
                }

                const voxelArray = Object.entries(this.voxels);
                if (voxelArray.length === 0) {
                    this.dirty = false;
                    return null;
                }

                // Create instanced mesh for voxels
                const geometry = new THREE.BoxGeometry(1, 1, 1);

                // Use MeshPhongMaterial for proper lighting
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: THREE.VertexColors,
                    shininess: 0 // No specular for blocky look
                });

                const instancedMesh = new THREE.InstancedMesh(geometry, material, voxelArray.length);
                const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                voxelArray.forEach(([key, voxel], i) => {
                    const [x, y, z] = key.split(',').map(Number);
                    const worldX = this.chunkX * this.chunkSize + x;
                    const worldY = this.chunkY * this.chunkSize + y;
                    const worldZ = this.chunkZ * this.chunkSize + z;

                    matrix.setPosition(worldX, worldY, worldZ);
                    instancedMesh.setMatrixAt(i, matrix);

                    // Set instance color
                    color.setHex(voxel.color);
                    instancedMesh.setColorAt(i, color);
                });

                instancedMesh.instanceMatrix.needsUpdate = true;
                if (instancedMesh.instanceColor) {
                    instancedMesh.instanceColor.needsUpdate = true;
                }

                // Disable frustum culling so chunks always render when loaded
                instancedMesh.frustumCulled = false;

                this.mesh = instancedMesh;
                this.dirty = false;

                console.log(`Chunk [${this.chunkX},${this.chunkY},${this.chunkZ}] built mesh with ${voxelArray.length} instances`);

                return this.mesh;
            }
        }

        class PlanetVoxelData {
            constructor(scene, planetRadius, voxelResolution = 128) {
                this.scene = scene;
                this.planetRadius = planetRadius;
                this.voxelResolution = voxelResolution; // How many voxels across the planet diameter
                this.voxelSize = (planetRadius * 2) / voxelResolution; // Size of each voxel in world units

                this.voxels = new Map(); // 'x,y,z' -> {type, color} - the planet's actual voxel data
                this.chunks = new Map(); // For rendering only
                this.chunkSize = 16;

                console.log(`Planet voxel data: ${voxelResolution}¬≥ resolution, ${this.voxelSize.toFixed(2)}m per voxel`);
            }

            // Generate the planet's voxel data from heightmap (do this ONCE at init)
            generatePlanetVoxels(heightFunc) {
                console.log('Generating planet voxel data...');
                const startTime = performance.now();
                let voxelCount = 0;

                // Iterate through a sphere of voxels
                const center = this.voxelResolution / 2;
                const radiusVoxels = this.voxelResolution / 2;

                for (let vx = 0; vx < this.voxelResolution; vx++) {
                    for (let vy = 0; vy < this.voxelResolution; vy++) {
                        for (let vz = 0; vz < this.voxelResolution; vz++) {
                            // Convert voxel coords to world position
                            const worldX = (vx - center) * this.voxelSize;
                            const worldY = (vy - center) * this.voxelSize;
                            const worldZ = (vz - center) * this.voxelSize;

                            const distFromCenter = Math.sqrt(worldX * worldX + worldY * worldY + worldZ * worldZ);

                            // Only process voxels inside the planet sphere
                            if (distFromCenter <= this.planetRadius + 20) {
                                // Sample height at this sphere position
                                const spherePos = {
                                    x: worldX / distFromCenter,
                                    y: worldY / distFromCenter,
                                    z: worldZ / distFromCenter
                                };

                                const surfaceHeight = heightFunc(spherePos);

                                // Is this voxel solid (below surface)?
                                if (distFromCenter <= surfaceHeight) {
                                    // Determine color based on height above sea level
                                    const heightAboveSurface = distFromCenter - this.planetRadius;
                                    const color = this.getTerrainColor(heightAboveSurface);

                                    this.voxels.set(`${vx},${vy},${vz}`, { type: 1, color });
                                    voxelCount++;
                                }
                            }
                        }
                    }
                }

                const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
                console.log(`Planet voxelization complete: ${voxelCount} voxels in ${elapsed}s`);
            }

            getTerrainColor(height) {
                // EXACT same logic as planet shader
                if (height < -5) return 0x2269B0; // Deep ocean
                if (height < 0) return 0x4D96C7;   // Shallow water
                if (height < 2) return 0xC2B380;   // Beach
                if (height < 10) return 0x4D9A4D;  // Grassland
                if (height < 18) return 0x3D833D;  // Forest
                if (height < 25) return 0x786358;  // Mountains
                return 0xF0F0FA;                   // Snow
            }

            chunkKey(cx, cy, cz) {
                return `${cx},${cy},${cz}`;
            }

            getChunk(cx, cy, cz) {
                // For now, just return empty - we'll implement proper planet voxel rendering later
                const key = this.chunkKey(cx, cy, cz);
                if (!this.chunks.has(key)) {
                    const chunk = new VoxelChunk(cx, cy, cz, this.chunkSize);
                    this.chunks.set(key, chunk);
                }
                return this.chunks.get(key);
            }

            updateChunks(playerPosition) {
                const playerChunkX = Math.floor(playerPosition.x / this.chunkSize);
                const playerChunkY = Math.floor(playerPosition.y / this.chunkSize);
                const playerChunkZ = Math.floor(playerPosition.z / this.chunkSize);

                console.log(`Updating chunks around player at chunk [${playerChunkX},${playerChunkY},${playerChunkZ}]`);

                let meshedCount = 0;

                // Load/update chunks around player
                for (let cx = playerChunkX - this.renderDistance; cx <= playerChunkX + this.renderDistance; cx++) {
                    for (let cy = Math.max(0, playerChunkY - 2); cy <= playerChunkY + 4; cy++) {
                        for (let cz = playerChunkZ - this.renderDistance; cz <= playerChunkZ + this.renderDistance; cz++) {
                            const chunk = this.getChunk(cx, cy, cz);

                            if (chunk.dirty) {
                                const mesh = chunk.buildMesh();
                                if (mesh && !mesh.parent) {
                                    this.scene.add(mesh);
                                    meshedCount++;
                                }
                            }
                        }
                    }
                }

                console.log(`Added ${meshedCount} chunk meshes to scene. Total chunks: ${this.chunks.size}`);

                // Unload distant chunks
                for (const [key, chunk] of this.chunks.entries()) {
                    const [cx, cy, cz] = key.split(',').map(Number);
                    const dx = Math.abs(cx - playerChunkX);
                    const dy = Math.abs(cy - playerChunkY);
                    const dz = Math.abs(cz - playerChunkZ);

                    if (dx > this.renderDistance + 2 || dy > 6 || dz > this.renderDistance + 2) {
                        if (chunk.mesh) {
                            this.scene.remove(chunk.mesh);
                            chunk.mesh.geometry.dispose();
                            chunk.mesh.material.dispose();
                            chunk.mesh = null;
                        }
                        this.chunks.delete(key);
                    }
                }
            }

            setVoxel(worldX, worldY, worldZ, type, color) {
                const cx = Math.floor(worldX / this.chunkSize);
                const cy = Math.floor(worldY / this.chunkSize);
                const cz = Math.floor(worldZ / this.chunkSize);

                const chunk = this.getChunk(cx, cy, cz);
                const localX = worldX - cx * this.chunkSize;
                const localY = worldY - cy * this.chunkSize;
                const localZ = worldZ - cz * this.chunkSize;

                chunk.setVoxel(localX, localY, localZ, type, color);
            }

            getVoxel(worldX, worldY, worldZ) {
                const cx = Math.floor(worldX / this.chunkSize);
                const cy = Math.floor(worldY / this.chunkSize);
                const cz = Math.floor(worldZ / this.chunkSize);

                const key = this.chunkKey(cx, cy, cz);
                if (!this.chunks.has(key)) return null;

                const chunk = this.chunks.get(key);
                const localX = worldX - cx * this.chunkSize;
                const localY = worldY - cy * this.chunkSize;
                const localZ = worldZ - cz * this.chunkSize;

                return chunk.getVoxel(localX, localY, localZ);
            }
        }

        // ===== PLANETARY WEATHER SYSTEM =====
        class PlanetaryWeatherSystem {
            constructor(scene, config = {}) {
                this.scene = scene;
                this.planet = config.planet;

                // Cloud layers - array of independent layers
                this.cloudLayers = [
                    {
                        altitude: 5.0,      // Start height above planet
                        thickness: 15.0,    // Layer thickness
                        scale: 0.6,         // Default to reasonable cloud size
                        size: 1.5,
                        density: 0.8,
                        coverage: 0.5,
                        concentration: 1.2,
                        waterWeight: 0.8,
                        randomness: 0.6,    // Noise variation
                        transparency: 0.95
                    }
                ];

                // Global cloud settings
                this.cloudConfig = {
                    windSpeed: 0.08,
                    windDirection: 0.785,
                    windCurl: 0.4,
                    shadowStrength: 0.7,
                    shadowSoftness: 0.5,
                    cloudGlow: 1.5
                };

                // Aurora configuration
                this.auroraConfig = {
                    intensity: 0.4,
                    speed: 0.5,
                    scale: 2.0
                };

                // Sun state
                this.sunAngle = Math.PI / 2;
                this.sunSpeed = 0.1;
                this.sunPaused = false;

                // Meshes
                this.planetMesh = null;
                this.cloudMesh = null;
                this.auroraMesh = null;

                this.initialize();
            }

            initialize() {
                this.createPlanet();
                this.createClouds();
                this.createAurora();
            }

            createPlanet() {
                const planetRadius = this.planet.radius;
                const geometry = new THREE.IcosahedronGeometry(planetRadius, 7);

                const material = new THREE.ShaderMaterial({
                    vertexShader: this.getPlanetVertexShader(),
                    fragmentShader: this.getPlanetFragmentShader(),
                    uniforms: {
                        uSunDir: { value: new THREE.Vector3(1, 0, 0) },
                        uSunColor: { value: new THREE.Color(1.0, 0.95, 0.8) },
                        uAmbientColor: { value: new THREE.Color(0.3, 0.4, 0.5) },
                        uTime: { value: 0 },
                        uShadowStrength: { value: this.cloudConfig.shadowStrength },
                        uShadowSoftness: { value: this.cloudConfig.shadowSoftness },
                        uWindSpeed: { value: this.cloudConfig.windSpeed },
                        uWindDir: { value: this.cloudConfig.windDirection },
                        uPlanetRadius: { value: this.planet.radius },
                        // Cloud layer data for shadow casting
                        uNumCloudLayers: { value: 0 },
                        uCloudAltitudes: { value: [] },
                        uCloudThicknesses: { value: [] },
                        uCloudScales: { value: [] },
                        uCloudCoverages: { value: [] },
                        uCloudDensities: { value: [] }
                    }
                });

                this.planetMesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.planetMesh);
            }

            createClouds() {
                this.cloudMeshes = [];

                // Simple: one sphere per layer, render both sides
                for (let i = 0; i < this.cloudLayers.length; i++) {
                    const layer = this.cloudLayers[i];
                    const cloudRadius = this.planet.radius + layer.altitude + layer.thickness;
                    const geometry = new THREE.IcosahedronGeometry(cloudRadius, 6);

                    const material = new THREE.ShaderMaterial({
                        vertexShader: this.getCloudVertexShader(),
                        fragmentShader: this.getCloudFragmentShader(),
                        uniforms: {
                            uTime: { value: 0 },
                            uLayerIndex: { value: i },
                            uScale: { value: layer.scale },
                            uSize: { value: layer.size },
                            uDensity: { value: layer.density },
                            uCoverage: { value: layer.coverage },
                            uConcentration: { value: layer.concentration },
                            uWaterWeight: { value: layer.waterWeight },
                            uRandomness: { value: layer.randomness },
                            uWindSpeed: { value: this.cloudConfig.windSpeed },
                            uWindDir: { value: this.cloudConfig.windDirection },
                            uWindCurl: { value: this.cloudConfig.windCurl },
                            uSunDir: { value: new THREE.Vector3(1, 0, 0) },
                            uSunColor: { value: new THREE.Color(1.0, 0.95, 0.8) },
                            uAmbientColor: { value: new THREE.Color(0.3, 0.4, 0.5) },
                            uCloudGlow: { value: this.cloudConfig.cloudGlow },
                            uTransparency: { value: layer.transparency },
                            uPlanetRadius: { value: this.planet.radius },
                            uCloudLayerAltitude: { value: layer.altitude },
                            uCloudLayerThickness: { value: layer.thickness },
                            cameraPos: { value: new THREE.Vector3() }
                        },
                        transparent: true,
                        side: THREE.DoubleSide,  // Render BOTH sides - front AND back
                        depthWrite: false,
                        depthTest: false,  // Don't test depth - render all clouds regardless
                        blending: THREE.NormalBlending
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.frustumCulled = false;  // Never cull
                    mesh.renderOrder = 1000 + i;  // Render after planet, in order
                    this.cloudMeshes.push(mesh);
                    this.scene.add(mesh);
                }
            }

            addCloudLayer() {
                // Add new layer above the highest existing layer
                const highestLayer = this.cloudLayers.reduce((max, layer) =>
                    Math.max(max, layer.altitude + layer.thickness), 0);

                const newLayer = {
                    altitude: highestLayer + 5,
                    thickness: 10.0,
                    scale: 0.6,
                    size: 1.5,
                    density: 0.6,
                    coverage: 0.4,
                    concentration: 1.0,
                    waterWeight: 0.7,
                    randomness: 0.5,
                    transparency: 0.95
                };

                this.cloudLayers.push(newLayer);
                this.rebuildClouds();
            }

            removeCloudLayer(index) {
                if (this.cloudLayers.length > 1) {
                    this.cloudLayers.splice(index, 1);
                    this.rebuildClouds();
                }
            }

            rebuildClouds() {
                // Remove existing cloud meshes
                for (const mesh of this.cloudMeshes) {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
                this.cloudMeshes = [];

                // Recreate clouds
                this.createClouds();
            }

            createAurora() {
                // Volumetric aurora shell - sparse ribbon beams
                const auroraRadius = this.planet.radius + 40;
                const geometry = new THREE.IcosahedronGeometry(auroraRadius, 4); // Lower subdivision to reduce visible geometry

                const material = new THREE.ShaderMaterial({
                    vertexShader: this.getAuroraVertexShader(),
                    fragmentShader: this.getAuroraFragmentShader(),
                    uniforms: {
                        uTime: { value: 0 },
                        uIntensity: { value: this.auroraConfig.intensity },
                        uSpeed: { value: this.auroraConfig.speed },
                        uScale: { value: 1.0 }, // Increased for proper beam scale
                        uPlanetRadius: { value: this.planet.radius },
                        uRotationAxis: { value: new THREE.Vector3(0.1, 1.0, 0.05).normalize() }, // Slight tilt
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    transparent: true,
                    side: THREE.DoubleSide, // Render both sides
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.auroraMesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.auroraMesh);
            }


            getPlanetVertexShader() {
                return `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vSpherePos;
                    varying float vHeight;

                    // Hash-based noise for vertex shader
                    float hash(vec3 p) {
                        p = fract(p * vec3(443.897, 441.423, 437.195));
                        p += dot(p, p.yxz + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }

                    float noise3d(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);

                        return mix(
                            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                    }

                    void main() {
                        vec3 spherePos = normalize(position);
                        vSpherePos = spherePos;

                        // Multi-octave 3D noise directly on sphere surface
                        float height = 0.0;
                        height += (noise3d(spherePos * 2.0) - 0.5) * 15.0;      // Continents
                        height += (noise3d(spherePos * 5.0) - 0.5) * 8.0;       // Mountain ranges
                        height += (noise3d(spherePos * 12.0) - 0.5) * 4.0;      // Hills
                        height += (noise3d(spherePos * 25.0) - 0.5) * 2.0;      // Detail

                        vHeight = height;

                        // Displace along sphere normal
                        vec3 displaced = position + spherePos * height * 0.5;
                        vPosition = displaced;
                        vNormal = normalize(normalMatrix * spherePos);

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                    }
                `;
            }

            getPlanetFragmentShader() {
                return `
                    uniform vec3 uSunDir;
                    uniform vec3 uSunColor;
                    uniform vec3 uAmbientColor;
                    uniform float uTime;
                    uniform float uShadowStrength;
                    uniform float uShadowSoftness;
                    uniform float uWindSpeed;
                    uniform float uWindDir;
                    uniform float uPlanetRadius;
                    uniform int uNumCloudLayers;
                    uniform float uCloudAltitudes[10];
                    uniform float uCloudThicknesses[10];
                    uniform float uCloudScales[10];
                    uniform float uCloudCoverages[10];
                    uniform float uCloudDensities[10];
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vSpherePos;
                    varying float vHeight;

                    // Atmospheric scattering constants
                    const vec3 rayleighCoeff = vec3(5.8, 13.5, 33.1);  // Blue sky scattering
                    const float mieCoeff = 21.0;                         // Haze/dust scattering
                    const float sunIntensity = 20.0;

                    // Hash for noise
                    float hash(vec3 p) {
                        p = fract(p * vec3(443.897, 441.423, 437.195));
                        p += dot(p, p.yxz + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }

                    float noise(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        return mix(
                            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                    }

                    // Terrain color based on height
                    vec3 getTerrainColor(float height, vec3 spherePos) {
                        vec3 color;

                        if (height < -5.0) {
                            // Deep ocean
                            color = vec3(0.13, 0.43, 0.69);
                        } else if (height < 0.0) {
                            // Shallow water
                            color = mix(vec3(0.13, 0.43, 0.69), vec3(0.30, 0.59, 0.78), (height + 5.0) / 5.0);
                        } else if (height < 2.0) {
                            // Beach/shore
                            color = vec3(0.76, 0.70, 0.50);
                        } else if (height < 10.0) {
                            // Grassland with variation
                            float variation = noise(spherePos * 40.0) * 0.1;
                            color = vec3(0.30, 0.60, 0.30) + vec3(variation);
                        } else if (height < 18.0) {
                            // Forest/hills with darker green
                            float variation = noise(spherePos * 60.0) * 0.08;
                            color = vec3(0.24, 0.51, 0.24) + vec3(variation);
                        } else if (height < 25.0) {
                            // Mountains - rocky brown/gray
                            float rockiness = noise(spherePos * 80.0);
                            color = mix(vec3(0.47, 0.39, 0.35), vec3(0.55, 0.55, 0.50), rockiness);
                        } else {
                            // Snow peaks
                            float snowVariation = noise(spherePos * 100.0) * 0.05;
                            color = vec3(0.94, 0.94, 0.98) + vec3(snowVariation);
                        }

                        return color;
                    }

                    // FBM noise for cloud density (simplified from cloud shader)
                    float fbm(vec3 p, float lacunarity) {
                        float value = 0.0;
                        float amplitude = 1.0;
                        for(int i = 0; i < 3; i++) {
                            value += amplitude * noise(p);
                            p *= lacunarity;
                            amplitude *= 0.5;
                        }
                        return value;
                    }

                    // Calculate cloud density at a position for a specific layer
                    float getLayerCloudDensity(vec3 pos, int layerIndex) {
                        float altitude = uCloudAltitudes[layerIndex];
                        float thickness = uCloudThicknesses[layerIndex];
                        float scale = uCloudScales[layerIndex];
                        float coverage = uCloudCoverages[layerIndex];
                        float density = uCloudDensities[layerIndex];

                        float innerRadius = uPlanetRadius + altitude;
                        float outerRadius = innerRadius + thickness;
                        float dist = length(pos);

                        // Check if position is within this cloud layer
                        if (dist < innerRadius || dist > outerRadius) return 0.0;

                        // Height within layer (0 = bottom, 1 = top)
                        float heightInLayer = (dist - innerRadius) / thickness;

                        // Wind offset
                        vec2 wind = vec2(cos(uWindDir), sin(uWindDir)) * uTime * uWindSpeed;
                        vec3 windOffset = vec3(wind.x, 0.0, wind.y);

                        // Sample cloud noise
                        vec3 samplePos = (pos + windOffset) * scale;
                        float cloudShape = fbm(samplePos, 2.1);

                        // Coverage threshold
                        cloudShape = smoothstep(coverage, coverage + 0.2, cloudShape);

                        // Vertical gradient (clouds denser in middle)
                        float verticalGradient = 1.0 - abs(heightInLayer - 0.5) * 0.5;

                        return cloudShape * verticalGradient * density;
                    }

                    // Ray-march toward sun to check for cloud shadows
                    float cloudShadow(vec3 surfacePos) {
                        if (uNumCloudLayers == 0) return 1.0;

                        // Ray from surface toward sun
                        vec3 rayOrigin = surfacePos + vNormal * 0.1; // Slightly above surface
                        vec3 rayDir = normalize(uSunDir);

                        float totalDensity = 0.0;
                        float maxDist = 200.0; // Maximum shadow casting distance
                        float stepSize = 5.0;

                        // March toward sun
                        for (float dist = 0.0; dist < maxDist; dist += stepSize) {
                            vec3 pos = rayOrigin + rayDir * dist;

                            // Check all cloud layers
                            for (int i = 0; i < 10; i++) {
                                if (i >= uNumCloudLayers) break;
                                totalDensity += getLayerCloudDensity(pos, i) * stepSize * 0.01;
                            }

                            // Early exit if heavily shadowed
                            if (totalDensity > 1.5) break;
                        }

                        // Convert density to shadow (0 = full shadow, 1 = no shadow)
                        float shadow = exp(-totalDensity * uShadowStrength);
                        return mix(1.0 - uShadowStrength, 1.0, shadow);
                    }

                    vec3 calculateAtmosphericScattering(vec3 viewDir, vec3 sunDir) {
                        float sunDot = dot(viewDir, sunDir);

                        // Rayleigh scattering (blue sky)
                        float rayleighPhase = 0.75 * (1.0 + sunDot * sunDot);
                        vec3 rayleigh = rayleighCoeff * rayleighPhase;

                        // Mie scattering (haze, forward scattering)
                        float g = 0.76; // Anisotropy factor
                        float g2 = g * g;
                        float miePhase = (1.0 - g2) / (pow(1.0 + g2 - 2.0 * g * sunDot, 1.5) * 4.0 * 3.14159);
                        float mie = mieCoeff * miePhase;

                        return (rayleigh + vec3(mie)) * 0.0001;
                    }

                    vec3 getSunColor(float sunHeight) {
                        // Sun height: 1.0 = zenith, 0.0 = horizon, -1.0 = below horizon
                        // Sunset/sunrise colors when near horizon
                        vec3 zenithColor = vec3(1.0, 0.95, 0.85);    // Slightly warm white
                        vec3 horizonColor = vec3(1.0, 0.5, 0.2);     // Orange/red
                        vec3 duskColor = vec3(0.8, 0.3, 0.4);        // Deep red/purple

                        if (sunHeight > 0.3) {
                            // High sun - neutral to slightly warm
                            return mix(horizonColor, zenithColor, (sunHeight - 0.3) / 0.7);
                        } else if (sunHeight > -0.1) {
                            // Near horizon - golden hour
                            float t = (sunHeight + 0.1) / 0.4;
                            return mix(duskColor, horizonColor, t);
                        } else {
                            // Below horizon - dark red
                            return duskColor * 0.3;
                        }
                    }

                    void main() {
                        vec3 baseColor = getTerrainColor(vHeight, vSpherePos);

                        // VOXELIZATION: Show cube tops when close enough
                        // Each voxel = 1m, so quantize height to nearest meter
                        float distToCam = length(vPosition - cameraPosition);
                        float voxelVisibility = smoothstep(500.0, 200.0, distToCam); // Fade in when closer than 500m

                        if (voxelVisibility > 0.01) {
                            // Quantize height to 1m voxel grid
                            float voxelHeight = floor(vHeight + 0.5); // Round to nearest meter
                            float heightFrac = fract(vHeight + 0.5);

                            // Detect if we're on top face of voxel (vs side faces)
                            // Use derivatives to detect sharp height changes
                            float dhdx = dFdx(vHeight);
                            float dhdy = dFdy(vHeight);
                            float slope = length(vec2(dhdx, dhdy));

                            // Top face detection: low slope = horizontal surface = top of voxel
                            float isTopFace = smoothstep(0.3, 0.1, slope);

                            // Grid lines on voxel tops (1m grid)
                            vec3 worldPos = vPosition;
                            vec2 gridPos = fract(worldPos.xz); // Assuming xz plane for horizontal
                            float gridLine = min(
                                smoothstep(0.05, 0.02, gridPos.x),
                                smoothstep(0.05, 0.02, gridPos.y)
                            );
                            gridLine += min(
                                smoothstep(0.95, 0.98, gridPos.x),
                                smoothstep(0.95, 0.98, gridPos.y)
                            );
                            gridLine = clamp(gridLine, 0.0, 1.0);

                            // Edge darkening on voxel tops
                            vec3 voxelEdge = vec3(0.2, 0.2, 0.25); // Slightly blue-tinted dark
                            baseColor = mix(baseColor, baseColor * 0.7 + voxelEdge * 0.3, gridLine * isTopFace * voxelVisibility);

                            // Side face shading (steeper slopes)
                            float isSideFace = 1.0 - isTopFace;
                            baseColor = mix(baseColor, baseColor * 0.85, isSideFace * voxelVisibility * 0.5);
                        }

                        // Calculate sun position relative to THIS POINT'S surface
                        float sunDot = dot(vNormal, uSunDir);

                        // Day/night transition for THIS POINT (not global!)
                        // If sun is below horizon at this location, it's night
                        float dayFactor = smoothstep(-0.1, 0.1, sunDot);

                        // Global sun height for atmospheric color
                        float sunHeight = uSunDir.y;

                        // Dynamic sun color based on time of day
                        vec3 dynamicSunColor = getSunColor(sunHeight);

                        // Cloud shadows
                        float shadow = cloudShadow(vPosition);

                        // Diffuse lighting with time-of-day color
                        float diffuseStrength = max(0.0, sunDot);
                        vec3 diffuse = dynamicSunColor * diffuseStrength * 0.8 * shadow * dayFactor;

                        // Ambient lighting - darker at night, bluer during day
                        vec3 dayAmbient = vec3(0.4, 0.5, 0.6);   // Slightly blue
                        vec3 nightAmbient = vec3(0.05, 0.05, 0.08); // Very dark blue
                        vec3 ambient = mix(nightAmbient, dayAmbient, dayFactor) * 0.4;

                        // Night side airglow (subtle blue/green glow on dark side)
                        float nightGlow = smoothstep(0.1, -0.2, sunHeight) * (1.0 - diffuseStrength);
                        vec3 airglow = vec3(0.1, 0.2, 0.3) * nightGlow * 0.3;

                        vec3 finalColor = baseColor * (diffuse + ambient) + airglow;

                        // Atmospheric scattering
                        vec3 viewDir = normalize(vPosition - cameraPosition);
                        vec3 scattering = calculateAtmosphericScattering(viewDir, uSunDir);

                        // Atmospheric haze based on distance and sun angle
                        float dist = length(vPosition - cameraPosition);
                        float atmosphereDensity = 1.0 - exp(-dist * 0.0005);

                        // Sky color varies with sun position
                        vec3 skyColor = mix(
                            vec3(0.1, 0.15, 0.3),              // Night sky
                            mix(
                                vec3(0.5, 0.6, 0.8),           // Blue sky
                                vec3(0.8, 0.5, 0.3),           // Orange horizon
                                smoothstep(0.5, -0.2, sunHeight)
                            ),
                            dayFactor
                        );

                        finalColor = mix(finalColor, skyColor + scattering * sunIntensity, atmosphereDensity * 0.15);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;
            }

            getCloudVertexShader() {
                return `
                    varying vec3 vPosition;
                    varying vec3 vWorldPos;
                    varying vec3 vNormal;

                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPos = worldPos.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
            }

            getCloudFragmentShader() {
                return `
                    varying vec3 vPosition;
                    varying vec3 vWorldPos;
                    varying vec3 vNormal;

                    uniform float uTime;
                    uniform float uScale;
                    uniform float uSize;
                    uniform float uDensity;
                    uniform float uCoverage;
                    uniform float uConcentration;
                    uniform float uWaterWeight;
                    uniform float uRandomness;
                    uniform float uWindSpeed;
                    uniform float uWindDir;
                    uniform float uWindCurl;
                    uniform vec3 uSunDir;
                    uniform vec3 uSunColor;
                    uniform vec3 uAmbientColor;
                    uniform float uCloudGlow;
                    uniform float uTransparency;
                    uniform float uPlanetRadius;
                    uniform float uCloudLayerAltitude;
                    uniform float uCloudLayerThickness;
                    uniform float uLayerIndex;
                    uniform vec3 cameraPos;

                    // Hash function for jitter
                    float hash(vec3 p) {
                        p = fract(p * 0.3183099 + 0.1);
                        p *= 17.0;
                        return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
                    }

                    // 3D Simplex noise
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    // Worley noise with water-weight clustering
                    float worley(vec3 p, float weight) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        float minDist = 10.0;

                        for(int x = -1; x <= 1; x++) {
                            for(int y = -1; y <= 1; y++) {
                                for(int z = -1; z <= 1; z++) {
                                    vec3 offset = vec3(float(x), float(y), float(z));
                                    vec3 h = i + offset;
                                    vec3 cellPos = offset + vec3(
                                        sin(dot(h, vec3(127.1, 311.7, 74.7))) * 43758.5453,
                                        sin(dot(h, vec3(269.5, 183.3, 246.1))) * 43758.5453,
                                        sin(dot(h, vec3(419.2, 371.9, 168.2))) * 43758.5453
                                    );
                                    cellPos = 0.5 + 0.5 * sin(cellPos * 6.2831853);

                                    // Apply water weight for clustering
                                    cellPos = mix(cellPos, vec3(0.5), weight * 0.3);

                                    float dist = length(f - offset - cellPos);
                                    minDist = min(minDist, dist);
                                }
                            }
                        }
                        return minDist;
                    }

                    // FBM with curl noise
                    float fbm(vec3 p, float curl) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        vec3 shift = vec3(100.0);

                        for (int i = 0; i < 5; i++) {
                            value += amplitude * snoise(p * frequency);

                            // Add curl distortion
                            p = p * 2.0 + shift * curl;

                            frequency *= 2.3;
                            amplitude *= 0.5;
                        }
                        return value;
                    }

                    // Advanced cloud density with all parameters and height variation
                    float getCloudDensity(vec3 p, float heightInLayer) {
                        // Wind pattern
                        vec2 wind = vec2(cos(uWindDir), sin(uWindDir));
                        vec3 windOffset = vec3(wind.x, 0.0, wind.y) * uTime * uWindSpeed;

                        // Add wind curl
                        windOffset += vec3(
                            snoise(p * uWindCurl + uTime * 0.1),
                            0.0,
                            snoise(p * uWindCurl * 1.3 + uTime * 0.1)
                        ) * uWindCurl * 2.0;

                        p += windOffset;

                        // Base cloud shape - actual 3D cloud forms
                        // Use lower frequency Worley for cloud "blobs"
                        float cloudBlobs = 1.0 - worley(p * uScale * 0.05 * uSize, uWaterWeight);

                        // Create distinct cloud formations with sharp edges
                        cloudBlobs = smoothstep(1.0 - uCoverage * 0.8, 1.0 - uCoverage * 0.3, cloudBlobs);

                        // Add medium-scale structure (cloud puffiness)
                        float cloudDetail = 1.0 - worley(p * uScale * 0.15 * uSize, uWaterWeight * 0.7);
                        cloudDetail = smoothstep(0.3, 0.7, cloudDetail);

                        // Combine blob shape with detail
                        float cloudShape = cloudBlobs * cloudDetail;

                        // THICKNESS: Modulate vertical extent of clouds
                        // Map layer thickness (5-50m range) to cloud vertical profile (0.0-2.0 multiplier)
                        float thicknessFactor = uCloudLayerThickness / 25.0; // Normalize around typical 25m
                        thicknessFactor = clamp(thicknessFactor, 0.2, 2.0);

                        // Vertical density gradient based on thickness
                        // Thin layers (5-15m): Flat stratus, uniform density
                        // Medium layers (15-30m): Stratocumulus, gentle gradient
                        // Thick layers (30-50m): Cumulus, strong vertical structure
                        float verticalGradient = 1.0;
                        if (thicknessFactor > 1.0) {
                            // THICK CUMULUS - towering, bottom-heavy
                            // Strong base, billowing top
                            float heightCurve = heightInLayer;
                            verticalGradient = mix(1.5, 0.3, pow(heightCurve, 1.5 / thicknessFactor));

                            // Add extra vertical structure/billowing for thick clouds
                            float billow = fbm(vec3(p.xz * uScale * 0.08, heightInLayer * 3.0), 0.6);
                            verticalGradient *= (0.8 + billow * 0.4);
                        } else if (thicknessFactor > 0.5) {
                            // MEDIUM STRATOCUMULUS - gentle roll
                            verticalGradient = mix(1.2, 0.8, smoothstep(0.2, 0.8, heightInLayer));
                        } else {
                            // THIN STRATUS - flat, uniform
                            verticalGradient = 1.0 - abs(heightInLayer - 0.5) * 0.3;
                        }

                        cloudShape *= verticalGradient;

                        // Erode edges for realistic cloud boundaries
                        float erosion = fbm(p * uScale * 0.3 * uSize, uRandomness);
                        cloudShape = cloudShape - (1.0 - erosion) * 0.3 * uRandomness;

                        // Fine detail with randomness
                        float fineDetail = snoise(p * uScale * 1.2 * uSize) * 0.1 * uRandomness;
                        cloudShape = clamp(cloudShape + fineDetail * cloudShape, 0.0, 1.0);

                        // Apply concentration (makes clouds puffier or wispier)
                        cloudShape = pow(max(cloudShape, 0.0), 2.0 - uConcentration);

                        // DENSITY affects overall opacity (more density = thicker looking)
                        return cloudShape * uDensity;
                    }

                    // Sphere intersection for volume entry/exit
                    vec2 sphereIntersect(vec3 ro, vec3 rd, float radius) {
                        float b = dot(ro, rd);
                        float c = dot(ro, ro) - radius * radius;
                        float d = b * b - c;
                        if (d < 0.0) return vec2(-1.0);
                        d = sqrt(d);
                        return vec2(-b - d, -b + d);
                    }

                    // Enhanced raymarching through TRUE 3D volume
                    vec4 raymarchClouds(vec3 rayOrigin, vec3 rayDir) {
                        // Define cloud volume boundaries for this specific layer
                        float innerRadius = uPlanetRadius + uCloudLayerAltitude;
                        float outerRadius = uPlanetRadius + uCloudLayerAltitude + uCloudLayerThickness;

                        // Find entry and exit points through cloud volume shell
                        vec2 outerHit = sphereIntersect(rayOrigin, rayDir, outerRadius);
                        vec2 innerHit = sphereIntersect(rayOrigin, rayDir, innerRadius);

                        float camDist = length(rayOrigin);

                        float tStart, tEnd;

                        // Camera outside cloud layer
                        if (camDist > outerRadius) {
                            // Both entry and exit can be valid for seeing through entire sphere
                            if (outerHit.y < 0.0) return vec4(0.0); // Completely missed

                            // Use whichever intersection is in front of camera
                            tStart = max(0.0, outerHit.x); // Enter outer sphere

                            // March all the way through - don't stop at inner sphere if viewing far side
                            if (innerHit.x > 0.0 && innerHit.x < outerHit.y) {
                                tEnd = innerHit.x; // Stop at planet surface
                            } else {
                                tEnd = outerHit.y; // Exit far side of clouds
                            }
                        }
                        // Camera inside cloud layer
                        else if (camDist > innerRadius && camDist <= outerRadius) {
                            tStart = 0.0; // Start from camera
                            if (innerHit.x > 0.0) {
                                tEnd = innerHit.x; // Stop at planet
                            } else {
                                tEnd = outerHit.y; // Exit clouds
                            }
                        }
                        // Camera inside planet (shouldn't happen)
                        else {
                            if (innerHit.y > 0.0) {
                                tStart = innerHit.y; // Exit planet
                                tEnd = outerHit.y; // Exit clouds
                            } else {
                                return vec4(0.0);
                            }
                        }

                        // Add small random offset to break banding artifacts
                        float jitter = hash(vec3(gl_FragCoord.xy * 0.1, uTime)) * 0.5;

                        // Fixed step size to avoid banding
                        float stepSize = 0.8;  // Fixed step size
                        float t = tStart + jitter;

                        float transmittance = 1.0;
                        vec3 cloudColor = vec3(0.0);

                        for(int i = 0; i < 50; i++) {
                            if(transmittance < 0.01 || t > tEnd) break;

                            vec3 pos = rayOrigin + rayDir * t;
                            float distFromCenter = length(pos);

                            // Only sample if inside cloud volume
                            if (distFromCenter >= innerRadius && distFromCenter <= outerRadius) {
                                // Calculate normalized height within layer (0.0 = inner, 1.0 = outer)
                                float heightInLayer = (distFromCenter - innerRadius) / uCloudLayerThickness;

                                // Sample cloud density with height variation
                                float cloudDensity = getCloudDensity(pos, heightInLayer);

                                if(cloudDensity > 0.01) {
                                    // Calculate if THIS POINT is in daylight
                                    vec3 surfaceNormal = normalize(pos);
                                    float sunDot = dot(surfaceNormal, uSunDir);

                                    // Day/night for this point
                                    float dayFactor = smoothstep(-0.1, 0.1, sunDot);

                                    // Global sun height for color
                                    float sunHeight = uSunDir.y;

                                    // Dynamic sun color (golden hour effect)
                                    vec3 zenithSunColor = vec3(1.0, 0.95, 0.85);
                                    vec3 horizonSunColor = vec3(1.0, 0.5, 0.2);
                                    vec3 duskSunColor = vec3(0.8, 0.3, 0.4);

                                    vec3 dynamicSunColor;
                                    if (sunHeight > 0.3) {
                                        dynamicSunColor = mix(horizonSunColor, zenithSunColor, (sunHeight - 0.3) / 0.7);
                                    } else if (sunHeight > -0.1) {
                                        dynamicSunColor = mix(duskSunColor, horizonSunColor, (sunHeight + 0.1) / 0.4);
                                    } else {
                                        dynamicSunColor = duskSunColor * 0.3;
                                    }

                                    // Multiple light samples for shadows
                                    vec3 lightPos1 = pos + uSunDir * 0.2;
                                    vec3 lightPos2 = pos + uSunDir * 0.5;
                                    float lightHeight1 = (length(lightPos1) - innerRadius) / uCloudLayerThickness;
                                    float lightHeight2 = (length(lightPos2) - innerRadius) / uCloudLayerThickness;

                                    float lightSample1 = getCloudDensity(lightPos1, lightHeight1);
                                    float lightSample2 = getCloudDensity(lightPos2, lightHeight2);
                                    float lightTransmittance = exp(-(lightSample1 * 2.0 + lightSample2 * 1.0));

                                    // Direct lighting from sun
                                    float directLight = pow(lightTransmittance, 0.8);

                                    // Ambient lighting varies with day/night
                                    vec3 dayAmbient = vec3(0.5, 0.6, 0.7) * 0.6;
                                    vec3 nightAmbient = vec3(0.05, 0.05, 0.1) * 0.3;
                                    vec3 ambient = mix(nightAmbient, dayAmbient, dayFactor);

                                    vec3 lit = mix(ambient, dynamicSunColor * uCloudGlow, directLight * dayFactor);

                                    // Golden hour: clouds lit from below/side
                                    float goldenHour = smoothstep(0.3, -0.1, sunHeight);
                                    if (goldenHour > 0.0) {
                                        // Clouds catch golden/orange light on undersides
                                        float underLight = smoothstep(0.5, 0.2, heightInLayer); // Bottom of clouds
                                        vec3 goldenTint = vec3(1.0, 0.6, 0.3) * goldenHour * underLight * 0.8;
                                        lit += goldenTint;
                                    }

                                    // Beer's law absorption
                                    float absorption = exp(-cloudDensity * stepSize * 0.08);
                                    cloudColor += (1.0 - absorption) * transmittance * lit;
                                    transmittance *= absorption;
                                }
                            }

                            t += stepSize;
                        }

                        return vec4(cloudColor, 1.0 - transmittance);
                    }

                    void main() {
                        // IMPORTANT: Ray direction from camera through this fragment
                        vec3 rayDir = normalize(vWorldPos - cameraPos);
                        vec3 rayOrigin = cameraPos;

                        // March through ENTIRE cloud volume, not just front surface
                        vec4 cloudResult = raymarchClouds(rayOrigin, rayDir);

                        // Early exit if no clouds hit
                        if (cloudResult.a < 0.001) {
                            discard;
                        }

                        vec3 finalColor = cloudResult.rgb;
                        float alpha = cloudResult.a;

                        // Atmospheric perspective
                        float dist = length(vWorldPos - cameraPos);
                        vec3 fogColor = mix(uAmbientColor, uSunColor * 0.5, 0.5);
                        finalColor = mix(finalColor, fogColor, 1.0 - exp(-dist * 0.0006));

                        gl_FragColor = vec4(finalColor, alpha * uTransparency);
                    }
                `;
            }

            getAuroraVertexShader() {
                return `
                    varying vec3 vPosition;
                    varying vec3 vNormal;

                    void main() {
                        vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
            }

            getAuroraFragmentShader() {
                return `
                    varying vec3 vPosition;
                    varying vec3 vNormal;

                    uniform float uTime;
                    uniform float uIntensity;
                    uniform float uSpeed;
                    uniform float uScale;
                    uniform float uPlanetRadius;
                    uniform vec3 uRotationAxis;
                    uniform vec3 cameraPos;

                    // Hash-based noise
                    float hash(vec3 p) {
                        p = fract(p * 0.3183099 + 0.1);
                        p *= 17.0;
                        return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
                    }

                    float noise(vec3 x) {
                        vec3 p = floor(x);
                        vec3 f = fract(x);
                        f = f * f * (3.0 - 2.0 * f);
                        return mix(
                            mix(mix(hash(p), hash(p + vec3(1,0,0)), f.x),
                                mix(hash(p + vec3(0,1,0)), hash(p + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(p + vec3(0,0,1)), hash(p + vec3(1,0,1)), f.x),
                                mix(hash(p + vec3(0,1,1)), hash(p + vec3(1,1,1)), f.x), f.y), f.z);
                    }

                    void main() {
                        vec3 spherePos = normalize(vPosition);
                        float distFromCenter = length(vPosition);

                        // Distance from rotational axis (magnetic latitude)
                        float distFromAxis = abs(dot(spherePos, uRotationAxis));

                        // Polar regions have stronger aurora (closer to axis = poles)
                        float polarStrength = pow(distFromAxis, 1.2);

                        // VERTICAL BEAM COORDINATES - selenite-like structure
                        // Use spherePos for angular position (where the beam is)
                        // Use distFromCenter for radial depth (how far down the beam)

                        // Angular coordinates for beam placement
                        vec3 perpendicular = normalize(cross(uRotationAxis, vec3(1.0, 0.0, 0.0)));
                        if (length(perpendicular) < 0.1) {
                            perpendicular = normalize(cross(uRotationAxis, vec3(0.0, 1.0, 0.0)));
                        }
                        vec3 binormal = normalize(cross(uRotationAxis, perpendicular));
                        float longitude = atan(dot(spherePos, binormal), dot(spherePos, perpendicular));
                        float latitude = dot(spherePos, uRotationAxis);

                        // Create discrete vertical beam positions (sparse ribbon-like)
                        vec2 beamCoord = vec2(longitude * 8.0, latitude * 8.0);

                        // Snap to beam grid with some randomness
                        vec2 beamCell = floor(beamCoord);
                        vec2 beamLocal = fract(beamCoord);

                        // Random offset per beam cell
                        float beamHash = hash(vec3(beamCell, 0.0));
                        float beamExists = step(0.65, beamHash); // Only 35% of cells have beams (more sparse)

                        // Create ribbon-like streaks (elongated in one direction)
                        float ribbonAngle = beamHash * 6.28;
                        vec2 ribbonDir = vec2(cos(ribbonAngle), sin(ribbonAngle));
                        vec2 toCenter = beamLocal - 0.5;

                        // Ribbon shape: thin perpendicular, elongated parallel
                        float perpDist = abs(dot(toCenter, vec2(-ribbonDir.y, ribbonDir.x)));
                        float paraLDist = abs(dot(toCenter, ribbonDir));

                        float ribbonWidth = 0.05;  // Very thin
                        float ribbonLength = 0.4;  // Elongated
                        float radialBeam = (1.0 - smoothstep(0.0, ribbonWidth, perpDist)) *
                                          (1.0 - smoothstep(0.0, ribbonLength, paraLDist));

                        // Animate beams falling down (moving inward radially)
                        float fallSpeed = uTime * uSpeed * 2.0;
                        float beamPhase = beamHash * 6.28; // Random phase per beam
                        float fallPosition = fract((distFromCenter * 0.04) - fallSpeed + beamPhase);

                        // Longer ribbon-like beams with soft gradients
                        float beamLength = 0.6;  // Longer streaks
                        float beamIntensity = smoothstep(0.0, 0.2, fallPosition) *
                                             smoothstep(beamLength, beamLength - 0.4, fallPosition);

                        // Add noise to beam for particle-like quality
                        float beamNoise = noise(vec3(beamCoord * 5.0, uTime * uSpeed * 2.0));
                        beamNoise = smoothstep(0.3, 0.7, beamNoise);

                        // Combine all factors
                        float streak = radialBeam * beamIntensity * beamExists * beamNoise;

                        // Height fade (stronger at higher altitudes)
                        float heightFactor = smoothstep(uPlanetRadius + 20.0, uPlanetRadius + 35.0, distFromCenter);
                        streak *= heightFactor;

                        // Combine with polar concentration
                        float intensity = streak * polarStrength * uIntensity * 2.0;

                        // Aurora colors - bright cyan/green like minecraft
                        vec3 color1 = vec3(0.1, 1.0, 0.9);   // Bright cyan
                        vec3 color2 = vec3(0.3, 0.9, 0.5);   // Green
                        vec3 color3 = vec3(0.5, 0.7, 1.0);   // Light blue

                        float colorMix = beamHash;
                        vec3 auroraColor = mix(color1, color2, colorMix);
                        auroraColor = mix(auroraColor, color3, beamNoise * 0.3);

                        // Bright core with glow
                        intensity *= (1.0 + beamIntensity * 2.0);

                        gl_FragColor = vec4(auroraColor, intensity);
                    }
                `;
            }

            update(deltaTime, cameraPos) {
                // Update sun
                if (!this.sunPaused) {
                    this.sunAngle += deltaTime * this.sunSpeed;
                }

                const sunDir = new THREE.Vector3(
                    Math.cos(this.sunAngle),
                    Math.sin(this.sunAngle) * 0.6,
                    Math.sin(this.sunAngle) * 0.4
                ).normalize();

                // Update all materials
                if (this.planetMesh) {
                    const pu = this.planetMesh.material.uniforms;
                    pu.uSunDir.value.copy(sunDir);
                    pu.uTime.value += deltaTime;

                    // Update cloud layer data for shadow casting
                    pu.uNumCloudLayers.value = this.cloudLayers.length;
                    const altitudes = [];
                    const thicknesses = [];
                    const scales = [];
                    const coverages = [];
                    const densities = [];

                    for (let i = 0; i < this.cloudLayers.length; i++) {
                        const layer = this.cloudLayers[i];
                        altitudes.push(layer.altitude);
                        thicknesses.push(layer.thickness);
                        scales.push(layer.scale);
                        coverages.push(layer.coverage);
                        densities.push(layer.density);
                    }

                    pu.uCloudAltitudes.value = altitudes;
                    pu.uCloudThicknesses.value = thicknesses;
                    pu.uCloudScales.value = scales;
                    pu.uCloudCoverages.value = coverages;
                    pu.uCloudDensities.value = densities;
                }

                // Update all cloud layer meshes
                for (const mesh of this.cloudMeshes) {
                    mesh.material.uniforms.uSunDir.value.copy(sunDir);
                    mesh.material.uniforms.uTime.value += deltaTime;
                    mesh.material.uniforms.cameraPos.value.copy(cameraPos);
                }

                if (this.auroraMesh) {
                    this.auroraMesh.material.uniforms.uTime.value += deltaTime;
                    this.auroraMesh.material.uniforms.cameraPos.value.copy(cameraPos);
                }

                return sunDir;
            }

            updateLayerUniforms(layerIndex) {
                if (layerIndex < 0 || layerIndex >= this.cloudMeshes.length) return;

                const layer = this.cloudLayers[layerIndex];
                const mesh = this.cloudMeshes[layerIndex];
                const u = mesh.material.uniforms;

                u.uScale.value = layer.scale;
                u.uSize.value = layer.size;
                u.uDensity.value = layer.density;
                u.uCoverage.value = layer.coverage;
                u.uConcentration.value = layer.concentration;
                u.uWaterWeight.value = layer.waterWeight;
                u.uRandomness.value = layer.randomness;
                u.uTransparency.value = layer.transparency;
                u.uCloudLayerAltitude.value = layer.altitude;
                u.uCloudLayerThickness.value = layer.thickness;

                // Update mesh geometry if altitude/thickness changed significantly
                const newRadius = this.planet.radius + layer.altitude + layer.thickness;
                if (Math.abs(mesh.geometry.parameters.radius - newRadius) > 1) {
                    mesh.geometry.dispose();
                    mesh.geometry = new THREE.IcosahedronGeometry(newRadius, 6);
                }
            }

            updateCloudConfig(config) {
                Object.assign(this.cloudConfig, config);

                // Update all cloud layer meshes with global settings
                for (const mesh of this.cloudMeshes) {
                    const u = mesh.material.uniforms;
                    u.uWindSpeed.value = this.cloudConfig.windSpeed;
                    u.uWindDir.value = this.cloudConfig.windDirection;
                    u.uWindCurl.value = this.cloudConfig.windCurl;
                    u.uCloudGlow.value = this.cloudConfig.cloudGlow;
                }

                const pu = this.planetMesh.material.uniforms;
                pu.uShadowStrength.value = this.cloudConfig.shadowStrength;
                pu.uShadowSoftness.value = this.cloudConfig.shadowSoftness;
                pu.uWindSpeed.value = this.cloudConfig.windSpeed;
                pu.uWindDir.value = this.cloudConfig.windDirection;
            }

            updateAuroraConfig(config) {
                Object.assign(this.auroraConfig, config);
                const u = this.auroraMesh.material.uniforms;
                u.uIntensity.value = this.auroraConfig.intensity;
                u.uSpeed.value = this.auroraConfig.speed;
                // Scale is now fixed at 0.1 for fine detail
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020308);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 100, 500);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls for first-person mode
        let controls;
        try {
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            console.log('PointerLockControls initialized successfully');
        } catch (e) {
            console.error('Failed to initialize PointerLockControls:', e);
            // Fallback: create a simple control object
            controls = {
                lock: () => console.log('Controls lock (fallback)'),
                unlock: () => console.log('Controls unlock (fallback)'),
                getObject: () => camera,
                isLocked: false
            };
        }

        let firstPersonMode = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const moveSpeed = 20.0;
        const keys = { forward: false, backward: false, left: false, right: false, up: false, down: false };

        // Planet voxel data manager
        const planetRadius = 150;
        const chunkManager = new PlanetVoxelData(scene, planetRadius, 64); // 64 voxel resolution
        console.log('PlanetVoxelData initialized');

        // Track last chunk update position to avoid excessive updates
        let lastChunkUpdatePos = new THREE.Vector3(Infinity, Infinity, Infinity);
        const chunkUpdateThreshold = 8; // Only update when player moves 8+ units

        // Lighting - use same lighting as planet (will be updated by weather system)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Dynamic sun light (position updated by weather system)
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        scene.add(sunLight);
        console.log('Added dynamic sun light for voxels (synced with weather system)');

        // Planet
        const planet = {
            radius: 150,
            position: new THREE.Vector3(0, 0, 0)
        };

        // Weather system
        const weatherSystem = new PlanetaryWeatherSystem(scene, { planet });

        // Connect chunk manager to planet heightmap
        // Simple noise-based height function matching the planet shader
        function hash(x, y, z) {
            x = Math.sin(x * 443.897 + y * 441.423 + z * 437.195) * 43758.5453;
            return x - Math.floor(x);
        }

        function noise3d(x, y, z) {
            const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
            const fx = x - ix, fy = y - iy, fz = z - iz;
            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);
            const sz = fz * fz * (3 - 2 * fz);

            const a = hash(ix, iy, iz);
            const b = hash(ix + 1, iy, iz);
            const c = hash(ix, iy + 1, iz);
            const d = hash(ix + 1, iy + 1, iz);
            const e = hash(ix, iy, iz + 1);
            const f = hash(ix + 1, iy, iz + 1);
            const g = hash(ix, iy + 1, iz + 1);
            const h = hash(ix + 1, iy + 1, iz + 1);

            const k0 = a + (b - a) * sx;
            const k1 = c + (d - c) * sx;
            const k2 = e + (f - e) * sx;
            const k3 = g + (h - g) * sx;

            const k4 = k0 + (k1 - k0) * sy;
            const k5 = k2 + (k3 - k2) * sy;

            return k4 + (k5 - k4) * sz;
        }

        function sampleTerrainHeight(worldX, worldZ, planetSurface) {
            // Convert flat world coordinates to sphere position
            // Position on planet surface at radius ~150 (planet radius from shader)
            const planetRadius = 150;

            // Sample 3D position on sphere surface
            const dist2d = Math.sqrt(worldX * worldX + worldZ * worldZ);
            const angle = Math.atan2(worldZ, worldX);
            const vertAngle = dist2d / planetRadius; // Angle from pole

            // Sphere position
            const sphereX = Math.sin(vertAngle) * Math.cos(angle);
            const sphereY = Math.cos(vertAngle);
            const sphereZ = Math.sin(vertAngle) * Math.sin(angle);

            // Sample noise at EXACT same scale as planet shader
            // Planet shader uses spherePos * scale for continents
            let height = 0;
            height += (noise3d(sphereX * 2, sphereY * 2, sphereZ * 2) - 0.5) * 15;  // Continents
            height += (noise3d(sphereX * 5, sphereY * 5, sphereZ * 5) - 0.5) * 8;   // Mountains
            height += (noise3d(sphereX * 12, sphereY * 12, sphereZ * 12) - 0.5) * 4; // Hills
            height += (noise3d(sphereX * 25, sphereY * 25, sphereZ * 25) - 0.5) * 2; // Detail

            // Return distance from origin (planet radius + height displacement)
            return planetRadius + height * 0.5; // 0.5 scale factor matches shader
        }

        chunkManager.setHeightFunction(sampleTerrainHeight, planet);

        // TODO: Implement proper planet voxel generation
        // For now, the voxel system is disabled pending proper implementation
        console.log('Voxel system initialized but not yet generating planet data');
        console.log('See planetary-weather-test-voxels.html for working example');

        // Camera controls
        let cameraAngle = { theta: 0, phi: Math.PI / 4 };
        let cameraDistance = 500;
        let mouseDown = false;
        let playerPosition = new THREE.Vector3(0, 110, 0); // Player spawn position

        document.addEventListener('mousedown', () => mouseDown = true);
        document.addEventListener('mouseup', () => mouseDown = false);
        document.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            cameraAngle.theta -= e.movementX * 0.005;
            cameraAngle.phi -= e.movementY * 0.005;
            cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.phi));
        });
        document.addEventListener('wheel', (e) => {
            cameraDistance += e.deltaY * 0.3;
            cameraDistance = Math.max(10, Math.min(2000, cameraDistance));
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            // First-person controls
            if (firstPersonMode) {
                switch(e.key.toLowerCase()) {
                    case 'w': keys.forward = true; break;
                    case 's': keys.backward = true; break;
                    case 'a': keys.left = true; break;
                    case 'd': keys.right = true; break;
                    case 'shift': keys.down = true; break;
                    case ' ': keys.up = true; e.preventDefault(); break;
                }
            }

            // Global hotkeys
            if (e.key === 'f') {
                // Toggle first-person mode
                firstPersonMode = !firstPersonMode;
                if (firstPersonMode) {
                    controls.lock();
                    // Position camera at player position
                    camera.position.copy(playerPosition);
                    // Immediately generate chunks around spawn point
                    chunkManager.updateChunks(camera.position);
                    console.log('First-person mode activated, generating terrain...');
                } else {
                    // Store player position when exiting first-person
                    playerPosition.copy(camera.position);
                    controls.unlock();
                    // Set up orbital camera around player position
                    cameraDistance = 50;
                    console.log('Returned to orbital mode');
                }
            }
            if (e.key.toLowerCase() === 'r') {
                // Reset to planet view
                playerPosition.set(0, 110, 0);
                cameraDistance = 500;
                cameraAngle = { theta: 0, phi: Math.PI / 4 };
                firstPersonMode = false;
                controls.unlock();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (firstPersonMode) {
                switch(e.key.toLowerCase()) {
                    case 'w': keys.forward = false; break;
                    case 's': keys.backward = false; break;
                    case 'a': keys.left = false; break;
                    case 'd': keys.right = false; break;
                    case 'shift': keys.down = false; break;
                    case ' ': keys.up = false; break;
                }
            }
        });

        // Dynamic Cloud Layer UI
        function buildCloudLayerUI() {
            const container = document.getElementById('cloudLayersContainer');
            container.innerHTML = '';

            weatherSystem.cloudLayers.forEach((layer, index) => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'control-group';
                layerDiv.style.border = '1px solid #2196F3';
                layerDiv.style.marginBottom = '10px';

                layerDiv.innerHTML = `
                    <h4 style="color: #2196F3; display: flex; justify-content: space-between;">
                        Layer ${index + 1}
                        ${weatherSystem.cloudLayers.length > 1 ? `<button class="danger" onclick="removeLayer(${index})" style="padding: 2px 8px; font-size: 10px;">‚úñ Remove</button>` : ''}
                    </h4>
                    <div>
                        <label>Altitude:</label>
                        <input type="range" data-layer="${index}" data-prop="altitude" min="0" max="50" step="1" value="${layer.altitude}">
                        <span class="value">${layer.altitude.toFixed(0)}m</span>
                    </div>
                    <div>
                        <label>Thickness:</label>
                        <input type="range" data-layer="${index}" data-prop="thickness" min="5" max="50" step="1" value="${layer.thickness}">
                        <span class="value">${layer.thickness.toFixed(0)}m</span>
                    </div>
                    <div>
                        <label>Scale:</label>
                        <input type="range" data-layer="${index}" data-prop="scale" min="0.1" max="3" step="0.1" value="${layer.scale}">
                        <span class="value">${layer.scale.toFixed(1)}x</span>
                    </div>
                    <div>
                        <label>Size:</label>
                        <input type="range" data-layer="${index}" data-prop="size" min="0.1" max="5" step="0.1" value="${layer.size}">
                        <span class="value">${layer.size.toFixed(1)}x</span>
                    </div>
                    <div>
                        <label>Density:</label>
                        <input type="range" data-layer="${index}" data-prop="density" min="0" max="2" step="0.05" value="${layer.density}">
                        <span class="value">${layer.density.toFixed(2)}</span>
                    </div>
                    <div>
                        <label>Coverage:</label>
                        <input type="range" data-layer="${index}" data-prop="coverage" min="0" max="1" step="0.05" value="${layer.coverage}">
                        <span class="value">${Math.round(layer.coverage * 100)}%</span>
                    </div>
                    <div>
                        <label>Concentration:</label>
                        <input type="range" data-layer="${index}" data-prop="concentration" min="0.1" max="3" step="0.1" value="${layer.concentration}">
                        <span class="value">${layer.concentration.toFixed(1)}x</span>
                    </div>
                    <div>
                        <label>Water Weight:</label>
                        <input type="range" data-layer="${index}" data-prop="waterWeight" min="0" max="2" step="0.1" value="${layer.waterWeight}">
                        <span class="value">${layer.waterWeight.toFixed(1)}</span>
                    </div>
                    <div>
                        <label>Randomness:</label>
                        <input type="range" data-layer="${index}" data-prop="randomness" min="0" max="2" step="0.1" value="${layer.randomness}">
                        <span class="value">${layer.randomness.toFixed(1)}</span>
                    </div>
                    <div>
                        <label>Transparency:</label>
                        <input type="range" data-layer="${index}" data-prop="transparency" min="0" max="1" step="0.05" value="${layer.transparency}">
                        <span class="value">${Math.round(layer.transparency * 100)}%</span>
                    </div>
                `;

                container.appendChild(layerDiv);
            });

            // Bind all layer controls
            container.querySelectorAll('input[type="range"]').forEach(slider => {
                const layerIndex = parseInt(slider.dataset.layer);
                const prop = slider.dataset.prop;
                const valueSpan = slider.nextElementSibling;

                slider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    weatherSystem.cloudLayers[layerIndex][prop] = val;
                    weatherSystem.updateLayerUniforms(layerIndex);

                    // Update display
                    if (prop === 'coverage' || prop === 'transparency') {
                        valueSpan.textContent = Math.round(val * 100) + '%';
                    } else if (prop === 'altitude' || prop === 'thickness') {
                        valueSpan.textContent = val.toFixed(0) + 'm';
                    } else if (prop.includes('scale') || prop.includes('size') || prop.includes('concentration')) {
                        valueSpan.textContent = val.toFixed(1) + 'x';
                    } else {
                        valueSpan.textContent = val.toFixed(2);
                    }
                });
            });

            document.getElementById('layerCount').textContent =
                weatherSystem.cloudLayers.length === 1 ? '1 layer' : `${weatherSystem.cloudLayers.length} layers`;
        }

        window.removeLayer = function(index) {
            weatherSystem.removeCloudLayer(index);
            buildCloudLayerUI();
        };

        document.getElementById('addCloudLayer').addEventListener('click', () => {
            weatherSystem.addCloudLayer();
            buildCloudLayerUI();
        });

        // Initial UI build
        buildCloudLayerUI();

        // Global cloud controls (only the ones that still exist in UI)
        const globalCloudControls = {
            windSpeed: (v) => weatherSystem.updateCloudConfig({ windSpeed: parseFloat(v) }),
            windDir: (v) => weatherSystem.updateCloudConfig({ windDirection: parseFloat(v) }),
            windCurl: (v) => weatherSystem.updateCloudConfig({ windCurl: parseFloat(v) }),
            shadowStrength: (v) => weatherSystem.updateCloudConfig({ shadowStrength: parseFloat(v) }),
            shadowSoftness: (v) => weatherSystem.updateCloudConfig({ shadowSoftness: parseFloat(v) }),
            cloudGlow: (v) => weatherSystem.updateCloudConfig({ cloudGlow: parseFloat(v) })
        };

        // Bind global sliders (with null check)
        for (const [id, callback] of Object.entries(globalCloudControls)) {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Val');
            if (slider && valueSpan) {
                slider.addEventListener('input', (e) => {
                    callback(e.target.value);
                    const val = parseFloat(e.target.value);
                    if (id.includes('Dir')) {
                        valueSpan.textContent = Math.round((val * 180 / Math.PI)) + '¬∞';
                    } else if (id.includes('Strength') || id.includes('Softness')) {
                        valueSpan.textContent = Math.round(val * 100) + '%';
                    } else {
                        valueSpan.textContent = val.toFixed(2) + (id.includes('Speed') || id.includes('Glow') ? 'x' : '');
                    }
                });
            }
        }

        // Sun controls
        document.getElementById('sunSpeed').addEventListener('input', (e) => {
            weatherSystem.sunSpeed = parseFloat(e.target.value);
            document.getElementById('sunSpeedVal').textContent = e.target.value + 'x';
        });

        document.getElementById('timeOfDay').addEventListener('input', (e) => {
            weatherSystem.sunAngle = parseFloat(e.target.value);
            document.getElementById('timeOfDayVal').textContent = Math.round(e.target.value * 180 / Math.PI) + '¬∞';
        });

        document.getElementById('toggleSun').addEventListener('click', () => {
            weatherSystem.sunPaused = !weatherSystem.sunPaused;
            document.getElementById('toggleSun').textContent = weatherSystem.sunPaused ? '‚ñ∂Ô∏è Resume Sun' : '‚è∏Ô∏è Pause Sun';
        });

        // Aurora controls
        document.getElementById('auroraIntensity').addEventListener('input', (e) => {
            weatherSystem.updateAuroraConfig({ intensity: parseFloat(e.target.value) });
            document.getElementById('auroraIntensityVal').textContent = Math.round(e.target.value * 100) + '%';
        });

        document.getElementById('auroraSpeed').addEventListener('input', (e) => {
            weatherSystem.updateAuroraConfig({ speed: parseFloat(e.target.value) });
            document.getElementById('auroraSpeedVal').textContent = e.target.value + 'x';
        });

        // Weather presets
        const presets = {
            presetClear: { coverage: 0.1, density: 0.3, concentration: 0.8 },
            presetPartly: { coverage: 0.4, density: 0.6, concentration: 1.0 },
            presetOvercast: { coverage: 0.8, density: 1.0, concentration: 1.5 },
            presetStormy: { coverage: 0.9, density: 1.5, concentration: 1.8, curl: 1.2, windSpeed: 0.15 },
            presetHeavy: { coverage: 1.0, density: 2.0, concentration: 2.0, waterWeight: 1.5 },
            presetWispy: { coverage: 0.3, density: 0.4, concentration: 0.5, curl: 0.9 }
        };

        for (const [id, config] of Object.entries(presets)) {
            document.getElementById(id).addEventListener('click', () => {
                weatherSystem.updateCloudConfig(config);
                // Update UI sliders
                for (const [key, val] of Object.entries(config)) {
                    const slider = document.getElementById('cloud' + key.charAt(0).toUpperCase() + key.slice(1));
                    if (slider) {
                        slider.value = val;
                        slider.dispatchEvent(new Event('input'));
                    }
                    if (key === 'windSpeed') {
                        document.getElementById('windSpeed').value = val;
                        document.getElementById('windSpeed').dispatchEvent(new Event('input'));
                    }
                    if (key === 'waterWeight') {
                        document.getElementById('waterWeight').value = val;
                        document.getElementById('waterWeight').dispatchEvent(new Event('input'));
                    }
                }
            });
        }

        // Camera presets
        document.getElementById('viewOrbit').addEventListener('click', () => { cameraDistance = 600; });
        document.getElementById('viewClose').addEventListener('click', () => { cameraDistance = 250; });
        document.getElementById('viewSurface').addEventListener('click', () => { cameraDistance = 180; });
        document.getElementById('viewVoxels').addEventListener('click', () => {
            // Teleport to view the test voxel chunk
            playerPosition.set(8, 104, 8); // Middle of chunk at Y=100
            cameraDistance = 50;
            cameraAngle = { theta: 0.5, phi: Math.PI / 3 };
            firstPersonMode = false;

            // Force chunk generation
            chunkManager.updateChunks(playerPosition);

            console.log('Camera moved to view voxels at:', playerPosition);
            console.log('Forced chunk update around player position');
        });
        document.getElementById('viewReset').addEventListener('click', () => {
            playerPosition.set(0, 110, 0);
            cameraDistance = 500;
            cameraAngle = { theta: 0, phi: Math.PI / 4 };
        });

        // Animation
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = (currentTime - lastTime) * 0.001;
            lastTime = currentTime;

            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1.0) {
                document.getElementById('fpsVal').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            // First-person mode
            if (firstPersonMode && controls.isLocked) {
                // WASD movement
                direction.set(0, 0, 0);

                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                direction.normalize();

                // Apply movement in camera's local space
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0; // Keep movement horizontal
                forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                velocity.set(0, 0, 0);
                velocity.addScaledVector(forward, -direction.z * moveSpeed * deltaTime);
                velocity.addScaledVector(right, direction.x * moveSpeed * deltaTime);

                // Vertical movement
                if (keys.up) velocity.y += moveSpeed * deltaTime;
                if (keys.down) velocity.y -= moveSpeed * deltaTime;

                controls.getObject().position.add(velocity);

                // Update player position
                playerPosition.copy(camera.position);

                // Update voxel chunks ONLY when player moves significantly (lazy loading)
                const distMoved = camera.position.distanceTo(lastChunkUpdatePos);
                if (distMoved > chunkUpdateThreshold) {
                    chunkManager.updateChunks(camera.position);
                    lastChunkUpdatePos.copy(camera.position);
                    console.log('Chunks updated, player moved', distMoved.toFixed(1), 'units');
                }

                // Hide planet mesh when in voxel mode
                if (weatherSystem.planetMesh) weatherSystem.planetMesh.visible = false;
                weatherSystem.cloudMeshes.forEach(m => m.visible = false);
                if (weatherSystem.auroraMesh) weatherSystem.auroraMesh.visible = false;
            } else {
                // Orbital camera mode - orbit around player position
                const offsetX = cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
                const offsetY = cameraDistance * Math.cos(cameraAngle.phi);
                const offsetZ = cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);

                camera.position.set(
                    playerPosition.x + offsetX,
                    playerPosition.y + offsetY,
                    playerPosition.z + offsetZ
                );
                camera.lookAt(playerPosition);

                // LOD system: show/hide planet based on camera distance from origin
                const distFromOrigin = camera.position.length();

                if (distFromOrigin < 200) {
                    // Close to surface - show voxels, hide planet
                    if (weatherSystem.planetMesh) weatherSystem.planetMesh.visible = false;
                    weatherSystem.cloudMeshes.forEach(m => m.visible = false);
                    if (weatherSystem.auroraMesh) weatherSystem.auroraMesh.visible = false;

                    // Generate voxel chunks around camera position (lazy - only if moved)
                    const distMoved = camera.position.distanceTo(lastChunkUpdatePos);
                    if (distMoved > chunkUpdateThreshold) {
                        chunkManager.updateChunks(camera.position);
                        lastChunkUpdatePos.copy(camera.position);
                    }
                } else {
                    // Far from surface - show planet, hide voxels
                    if (weatherSystem.planetMesh) weatherSystem.planetMesh.visible = true;
                    weatherSystem.cloudMeshes.forEach(m => m.visible = true);
                    if (weatherSystem.auroraMesh) weatherSystem.auroraMesh.visible = true;
                }
            }

            // Update weather system
            const sunDir = weatherSystem.update(deltaTime, camera.position);

            // Sync voxel sun light with weather system's sun
            sunLight.position.copy(sunDir).multiplyScalar(1000);
            sunLight.position.add(camera.position); // Position relative to camera

            // Update stats
            document.getElementById('distanceVal').textContent = Math.round(camera.position.length());
            document.getElementById('sunAngle').textContent = Math.round((weatherSystem.sunAngle * 180 / Math.PI) % 360);
            document.getElementById('cloudCoverage').textContent = Math.round(weatherSystem.cloudConfig.coverage * 100);
            document.getElementById('shadowIntensity').textContent = Math.round(weatherSystem.cloudConfig.shadowStrength * 100);

            renderer.render(scene, camera);
        }

        animate(performance.now());

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
