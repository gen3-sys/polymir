<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymir Volumetric Cloud System</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; background: #87CEEB; }
        #controls { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(20,20,20,0.9); 
            padding: 15px; 
            border-radius: 5px;
            color: white;
            max-height: 90vh;
            overflow-y: auto;
            width: 280px;
        }
        #controls h3 { margin: 0 0 10px 0; color: #87CEEB; }
        .control-group { 
            margin: 10px 0; 
            padding: 10px; 
            background: rgba(40,40,40,0.8); 
            border-radius: 3px;
        }
        .layer-controls {
            margin: 10px 0;
            padding: 10px;
            background: rgba(30,30,30,0.9);
            border-radius: 3px;
            border-left: 3px solid #87CEEB;
        }
        .layer-controls h4 {
            margin: 0 0 10px 0;
            color: #87CEEB;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px;
        }
        button:hover { background: #45a049; }
        button.remove {
            background: #f44336;
            padding: 2px 6px;
            font-size: 11px;
        }
        button.remove:hover { background: #da190b; }
        input[type="range"] {
            width: 140px;
            vertical-align: middle;
        }
        label {
            display: inline-block;
            width: 100px;
            font-size: 11px;
        }
        .value {
            display: inline-block;
            width: 45px;
            text-align: right;
            color: #87CEEB;
            font-size: 11px;
        }
        #fps {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Volumetric Cloud System</h3>
        <div class="control-group">
            <button id="addLayer">+ Add Cloud Layer</button>
            <button id="preset1">Earth Cumulus</button>
            <button id="preset2">Storm Clouds</button>
            <button id="preset3">Wispy Cirrus</button>
            <button id="clearAll">Clear All</button>
        </div>
        <div id="layersContainer">
            <!-- Default cumulus layer -->
            <div class="layer-controls" id="layer0">
                <h4>Cumulus Layer <button class="remove">×</button></h4>
                <div>
                    <label>Shell Height:</label>
                    <input type="range" class="height" min="1.02" max="1.5" step="0.01" value="1.08">
                    <span class="value heightVal">1.08</span>
                </div>
                <div>
                    <label>Cloud Density:</label>
                    <input type="range" class="density" min="0" max="2" step="0.01" value="0.8">
                    <span class="value densityVal">0.80</span>
                </div>
                <div>
                    <label>Coverage:</label>
                    <input type="range" class="coverage" min="0" max="1" step="0.01" value="0.6">
                    <span class="value coverageVal">0.60</span>
                </div>
                <div>
                    <label>Puffiness:</label>
                    <input type="range" class="puffiness" min="0" max="1" step="0.01" value="0.7">
                    <span class="value puffinessVal">0.70</span>
                </div>
                <div>
                    <label>Cloud Scale:</label>
                    <input type="range" class="scale" min="0.1" max="3" step="0.1" value="1.2">
                    <span class="value scaleVal">1.2</span>
                </div>
                <div>
                    <label>Wind Speed:</label>
                    <input type="range" class="windSpeed" min="0" max="0.05" step="0.001" value="0.008">
                    <span class="value windSpeedVal">0.008</span>
                </div>
                <div>
                    <label>Turbulence:</label>
                    <input type="range" class="turbulence" min="0" max="1" step="0.01" value="0.3">
                    <span class="value turbulenceVal">0.30</span>
                </div>
            </div>
        </div>
    </div>
    <div id="fps">FPS: <span id="fpsVal">0</span></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Volumetric cloud vertex shader
        const volumetricVertexShader = `
            varying vec3 vPosition;
            varying vec3 vWorldPos;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            void main() {
                vPosition = position;
                vNormal = normalize(normalMatrix * normal);
                vUv = uv;
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vWorldPos = worldPos.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Volumetric cloud fragment shader with raymarching
        const volumetricFragmentShader = `
            varying vec3 vPosition;
            varying vec3 vWorldPos;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            uniform float time;
            uniform float density;
            uniform float coverage;
            uniform float puffiness;
            uniform float scale;
            uniform float turbulence;
            uniform vec3 cameraPos;
            
            // 3D Noise functions
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            // Worley noise for puffy cumulus shapes
            float worley(vec3 p) {
                vec3 i = floor(p);
                vec3 f = fract(p);
                
                float minDist = 1.0;
                for(int x = -1; x <= 1; x++) {
                    for(int y = -1; y <= 1; y++) {
                        for(int z = -1; z <= 1; z++) {
                            vec3 offset = vec3(float(x), float(y), float(z));
                            vec3 cellPos = offset + vec3(
                                sin(dot(i + offset, vec3(127.1, 311.7, 74.7))) * 43758.5453,
                                sin(dot(i + offset, vec3(269.5, 183.3, 246.1))) * 43758.5453,
                                sin(dot(i + offset, vec3(419.2, 371.9, 168.2))) * 43758.5453
                            );
                            cellPos = 0.5 + 0.5 * sin(cellPos * 6.2831853);
                            float dist = length(f - offset - cellPos);
                            minDist = min(minDist, dist);
                        }
                    }
                }
                return minDist;
            }
            
            // Multi-octave FBM for cloud detail
            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for (int i = 0; i < 4; i++) {
                    value += amplitude * snoise(p * frequency);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                
                return value;
            }
            
            // Volumetric cloud density function
            float getCloudDensity(vec3 p) {
                vec3 windOffset = vec3(time * 0.1, 0.0, time * 0.05);
                p += windOffset;
                
                // Large scale cumulus shape using Worley noise
                float cloudShape = 1.0 - worley(p * scale * 0.08);
                cloudShape = pow(cloudShape, 2.0 - puffiness);
                
                // Add turbulent detail
                float detail = fbm(p * scale * 0.3) * turbulence;
                cloudShape += detail * 0.5;
                
                // Coverage threshold
                cloudShape = smoothstep(1.0 - coverage, 1.0 - coverage + 0.3, cloudShape);
                
                // Add small scale detail for wispy edges
                float smallDetail = snoise(p * scale * 0.8) * 0.2;
                cloudShape += smallDetail * cloudShape;
                
                return cloudShape * density;
            }
            
            // Simple raymarching through cloud volume
            vec4 raymarchClouds(vec3 rayOrigin, vec3 rayDir, float maxDist) {
                float stepSize = 0.1;
                vec3 pos = rayOrigin;
                float transmittance = 1.0;
                vec3 cloudColor = vec3(0.0);
                
                // Light direction (sun)
                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                vec3 ambientColor = vec3(0.4, 0.5, 0.6);
                vec3 sunColor = vec3(1.0, 0.95, 0.8);
                
                for(int i = 0; i < 20; i++) {
                    if(transmittance < 0.01) break;
                    
                    float cloudDensity = getCloudDensity(pos);
                    
                    if(cloudDensity > 0.01) {
                        // Simple lighting
                        float lightSample = getCloudDensity(pos + lightDir * 0.2);
                        float lightTransmittance = exp(-lightSample * 2.0);
                        
                        vec3 lit = mix(ambientColor, sunColor, lightTransmittance);
                        
                        // Beer's law absorption
                        float absorption = exp(-cloudDensity * stepSize * 4.0);
                        cloudColor += (1.0 - absorption) * transmittance * lit;
                        transmittance *= absorption;
                    }
                    
                    pos += rayDir * stepSize;
                    if(length(pos - rayOrigin) > maxDist) break;
                }
                
                return vec4(cloudColor, 1.0 - transmittance);
            }
            
            void main() {
                // Calculate ray direction from camera to fragment
                vec3 rayDir = normalize(vWorldPos - cameraPos);
                vec3 rayOrigin = vWorldPos;
                
                // Raymarch through cloud volume on the shell
                vec4 cloudResult = raymarchClouds(rayOrigin, rayDir * 0.1, 1.0);
                
                // Composite with background
                vec3 finalColor = cloudResult.rgb;
                float alpha = cloudResult.a;
                
                // Add some atmospheric perspective
                float dist = length(vWorldPos - cameraPos);
                vec3 fogColor = vec3(0.7, 0.8, 0.9);
                finalColor = mix(finalColor, fogColor, 1.0 - exp(-dist * 0.002));
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Base planet
        const baseRadius = 10;
        const baseThickness = 3;
        const baseGeometry = new THREE.TorusGeometry(baseRadius, baseThickness, 32, 200);
        const baseMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4A5F3A,
            shininess: 5
        });
        const planetSurface = new THREE.Mesh(baseGeometry, baseMaterial);
        scene.add(planetSurface);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        // Cloud layers array
        const cloudLayers = [];
        let layerIdCounter = 0;
        
        // Function to create volumetric cloud shell
        function createCloudShell(config) {
            const shellGeometry = baseGeometry.clone();
            const positions = shellGeometry.attributes.position;
            const normals = shellGeometry.attributes.normal;
            
            const offsetDistance = (config.height - 1.0) * baseThickness * 3;
            
            for (let i = 0; i < positions.count; i++) {
                positions.setXYZ(
                    i,
                    positions.getX(i) + normals.getX(i) * offsetDistance,
                    positions.getY(i) + normals.getY(i) * offsetDistance,
                    positions.getZ(i) + normals.getZ(i) * offsetDistance
                );
            }
            
            positions.needsUpdate = true;
            shellGeometry.computeVertexNormals();
            
            const shellMaterial = new THREE.ShaderMaterial({
                vertexShader: volumetricVertexShader,
                fragmentShader: volumetricFragmentShader,
                uniforms: {
                    time: { value: 0 },
                    density: { value: config.density },
                    coverage: { value: config.coverage },
                    puffiness: { value: config.puffiness },
                    scale: { value: config.scale },
                    turbulence: { value: config.turbulence },
                    cameraPos: { value: camera.position }
                },
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const shellMesh = new THREE.Mesh(shellGeometry, shellMaterial);
            scene.add(shellMesh);
            
            return {
                id: config.id,
                mesh: shellMesh,
                material: shellMaterial,
                geometry: shellGeometry,
                config: config,
                windSpeed: config.windSpeed
            };
        }
        
        // Create default cumulus layer
        let defaultLayer = createCloudShell({
            id: 'layer0',
            height: 1.08,
            density: 0.8,
            coverage: 0.6,
            puffiness: 0.7,
            scale: 1.2,
            turbulence: 0.3,
            windSpeed: 0.008
        });
        cloudLayers.push(defaultLayer);
        
        // Update layer height
        function updateLayerHeight(layer, newHeight) {
            scene.remove(layer.mesh);
            layer.geometry.dispose();
            
            const shellGeometry = baseGeometry.clone();
            const positions = shellGeometry.attributes.position;
            const normals = shellGeometry.attributes.normal;
            
            const offsetDistance = (newHeight - 1.0) * baseThickness * 3;
            
            for (let i = 0; i < positions.count; i++) {
                positions.setXYZ(
                    i,
                    positions.getX(i) + normals.getX(i) * offsetDistance,
                    positions.getY(i) + normals.getY(i) * offsetDistance,
                    positions.getZ(i) + normals.getZ(i) * offsetDistance
                );
            }
            
            positions.needsUpdate = true;
            shellGeometry.computeVertexNormals();
            
            layer.geometry = shellGeometry;
            layer.mesh.geometry = shellGeometry;
            layer.config.height = newHeight;
            scene.add(layer.mesh);
        }
        
        // Bind controls for default layer
        function bindLayerControls(controlsDiv, layer) {
            controlsDiv.querySelector('.height').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.heightVal').textContent = val.toFixed(2);
                updateLayerHeight(layer, val);
            });
            
            controlsDiv.querySelector('.density').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.densityVal').textContent = val.toFixed(2);
                layer.material.uniforms.density.value = val;
            });
            
            controlsDiv.querySelector('.coverage').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.coverageVal').textContent = val.toFixed(2);
                layer.material.uniforms.coverage.value = val;
            });
            
            controlsDiv.querySelector('.puffiness').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.puffinessVal').textContent = val.toFixed(2);
                layer.material.uniforms.puffiness.value = val;
            });
            
            controlsDiv.querySelector('.scale').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.scaleVal').textContent = val.toFixed(1);
                layer.material.uniforms.scale.value = val;
            });
            
            controlsDiv.querySelector('.windSpeed').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.windSpeedVal').textContent = val.toFixed(3);
                layer.windSpeed = val;
            });
            
            controlsDiv.querySelector('.turbulence').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                controlsDiv.querySelector('.turbulenceVal').textContent = val.toFixed(2);
                layer.material.uniforms.turbulence.value = val;
            });
            
            const removeBtn = controlsDiv.querySelector('.remove');
            if (removeBtn) {
                removeBtn.addEventListener('click', () => {
                    const idx = cloudLayers.findIndex(l => l.id === layer.id);
                    if (idx > -1) {
                        scene.remove(layer.mesh);
                        layer.geometry.dispose();
                        layer.material.dispose();
                        cloudLayers.splice(idx, 1);
                    }
                    controlsDiv.remove();
                });
            }
        }
        
        bindLayerControls(document.getElementById('layer0'), defaultLayer);
        
        // Add new cloud layer
        document.getElementById('addLayer').addEventListener('click', () => {
            const layerId = `layer${++layerIdCounter}`;
            const height = 1.1 + layerIdCounter * 0.08;
            
            const newLayer = createCloudShell({
                id: layerId,
                height: height,
                density: 0.8,
                coverage: 0.5,
                puffiness: 0.6,
                scale: 1.0,
                turbulence: 0.4,
                windSpeed: 0.01
            });
            cloudLayers.push(newLayer);
            
            // Create controls
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'layer-controls';
            controlsDiv.id = layerId;
            controlsDiv.innerHTML = `
                <h4>Cloud Layer ${layerIdCounter} <button class="remove">×</button></h4>
                <div>
                    <label>Shell Height:</label>
                    <input type="range" class="height" min="1.02" max="1.5" step="0.01" value="${height.toFixed(2)}">
                    <span class="value heightVal">${height.toFixed(2)}</span>
                </div>
                <div>
                    <label>Cloud Density:</label>
                    <input type="range" class="density" min="0" max="2" step="0.01" value="0.8">
                    <span class="value densityVal">0.80</span>
                </div>
                <div>
                    <label>Coverage:</label>
                    <input type="range" class="coverage" min="0" max="1" step="0.01" value="0.5">
                    <span class="value coverageVal">0.50</span>
                </div>
                <div>
                    <label>Puffiness:</label>
                    <input type="range" class="puffiness" min="0" max="1" step="0.01" value="0.6">
                    <span class="value puffinessVal">0.60</span>
                </div>
                <div>
                    <label>Cloud Scale:</label>
                    <input type="range" class="scale" min="0.1" max="3" step="0.1" value="1.0">
                    <span class="value scaleVal">1.0</span>
                </div>
                <div>
                    <label>Wind Speed:</label>
                    <input type="range" class="windSpeed" min="0" max="0.05" step="0.001" value="0.01">
                    <span class="value windSpeedVal">0.010</span>
                </div>
                <div>
                    <label>Turbulence:</label>
                    <input type="range" class="turbulence" min="0" max="1" step="0.01" value="0.4">
                    <span class="value turbulenceVal">0.40</span>
                </div>
            `;
            document.getElementById('layersContainer').appendChild(controlsDiv);
            
            bindLayerControls(controlsDiv, newLayer);
        });
        
        // Presets
        document.getElementById('preset1').addEventListener('click', () => {
            // Earth cumulus
            if (cloudLayers[0]) {
                const layer = cloudLayers[0];
                layer.material.uniforms.density.value = 0.8;
                layer.material.uniforms.coverage.value = 0.6;
                layer.material.uniforms.puffiness.value = 0.7;
                layer.material.uniforms.scale.value = 1.2;
                layer.material.uniforms.turbulence.value = 0.3;
                layer.windSpeed = 0.008;
                
                // Update UI
                const controls = document.getElementById(layer.id);
                if (controls) {
                    controls.querySelector('.densityVal').textContent = '0.80';
                    controls.querySelector('.coverageVal').textContent = '0.60';
                    controls.querySelector('.puffinessVal').textContent = '0.70';
                    controls.querySelector('.scaleVal').textContent = '1.2';
                    controls.querySelector('.turbulenceVal').textContent = '0.30';
                    controls.querySelector('.windSpeedVal').textContent = '0.008';
                }
            }
        });
        
        document.getElementById('preset2').addEventListener('click', () => {
            // Storm clouds
            if (cloudLayers[0]) {
                const layer = cloudLayers[0];
                layer.material.uniforms.density.value = 1.5;
                layer.material.uniforms.coverage.value = 0.9;
                layer.material.uniforms.puffiness.value = 0.3;
                layer.material.uniforms.scale.value = 1.8;
                layer.material.uniforms.turbulence.value = 0.7;
                layer.windSpeed = 0.02;
                
                const controls = document.getElementById(layer.id);
                if (controls) {
                    controls.querySelector('.densityVal').textContent = '1.50';
                    controls.querySelector('.coverageVal').textContent = '0.90';
                    controls.querySelector('.puffinessVal').textContent = '0.30';
                    controls.querySelector('.scaleVal').textContent = '1.8';
                    controls.querySelector('.turbulenceVal').textContent = '0.70';
                    controls.querySelector('.windSpeedVal').textContent = '0.020';
                }
            }
        });
        
        document.getElementById('preset3').addEventListener('click', () => {
            // Wispy cirrus
            if (cloudLayers[0]) {
                const layer = cloudLayers[0];
                layer.material.uniforms.density.value = 0.3;
                layer.material.uniforms.coverage.value = 0.4;
                layer.material.uniforms.puffiness.value = 0.9;
                layer.material.uniforms.scale.value = 2.5;
                layer.material.uniforms.turbulence.value = 0.8;
                layer.windSpeed = 0.015;
                
                const controls = document.getElementById(layer.id);
                if (controls) {
                    controls.querySelector('.densityVal').textContent = '0.30';
                    controls.querySelector('.coverageVal').textContent = '0.40';
                    controls.querySelector('.puffinessVal').textContent = '0.90';
                    controls.querySelector('.scaleVal').textContent = '2.5';
                    controls.querySelector('.turbulenceVal').textContent = '0.80';
                    controls.querySelector('.windSpeedVal').textContent = '0.015';
                }
            }
        });
        
        document.getElementById('clearAll').addEventListener('click', () => {
            cloudLayers.forEach(layer => {
                scene.remove(layer.mesh);
                layer.geometry.dispose();
                layer.material.dispose();
                const controlEl = document.getElementById(layer.id);
                if (controlEl) controlEl.remove();
            });
            cloudLayers.length = 0;
            layerIdCounter = 0;
        });
        
        // Mouse controls
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
            targetRotationY = mouseX * Math.PI;
            targetRotationX = mouseY * Math.PI * 0.5;
        });
        
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(10, Math.min(50, camera.position.z));
        });
        
        // Animation
        let frameCount = 0;
        let fpsTime = 0;
        let lastFrameTime = performance.now();
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastFrameTime) * 0.001;
            lastFrameTime = currentTime;
            
            // FPS counter
            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1.0) {
                document.getElementById('fpsVal').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }
            
            // Smooth rotation
            planetSurface.rotation.x += (targetRotationX - planetSurface.rotation.x) * 0.05;
            planetSurface.rotation.y += (targetRotationY - planetSurface.rotation.y) * 0.05;
            
            // Update each layer
            cloudLayers.forEach(layer => {
                layer.material.uniforms.time.value += deltaTime * layer.windSpeed;
                layer.material.uniforms.cameraPos.value = camera.position;
                layer.mesh.rotation.x = planetSurface.rotation.x;
                layer.mesh.rotation.y = planetSurface.rotation.y;
            });
            
            renderer.render(scene, camera);
        }
        
        animate(performance.now());
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>