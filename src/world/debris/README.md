# Debris Aggregation System

A two-layer voxel system for POLYMIR that allows comets, asteroids, and debris to interact with planets through impacts, settling, cratering, and moon capture - all while preserving the original generated terrain.

## Architecture Overview

### Two-Layer Voxel System

```
┌─────────────────────────────────┐
│  BASE LAYER (Immutable)         │
│  - Generated by SphereGenerator │
│  - Never modified after gen     │
│  - Stored in planet.chunks      │
├─────────────────────────────────┤
│  DAMAGE MAP (Dynamic)           │
│  - Modified by debris impacts   │
│  - Stored separately per chunk  │
│  - Can be saved/loaded/reset    │
└─────────────────────────────────┘
```

**Key Benefit**: Original planet terrain is never destroyed. Damage can be rolled back, saved separately, or completely reset.

---

## Components

### 1. **ChunkDamageData.js**
Tracks per-chunk modifications (added/removed voxels, impact history).

```javascript
const damageData = new ChunkDamageData({cx: 0, cy: 0, cz: 0});

// Add settled debris
damageData.addVoxel(5, 10, 3, colorId);

// Create crater
damageData.removeVoxel(8, 12, 7);

// Get merged voxels (base + damage)
const mergedVoxels = damageData.getMergedVoxelData(baseChunkVoxels);
```

**Features**:
- Sparse storage (only stores changes)
- Impact history tracking
- Serialization for save/load
- Dirty flag for mesh rebuilds

---

### 2. **DebrisEntity.js**
Represents a debris object in space.

```javascript
const debris = new DebrisEntity({
    position: new THREE.Vector3(0, 200, 0),
    velocity: new THREE.Vector3(10, -30, 5),
    angularVelocity: new THREE.Vector3(0.5, 1.0, 0.2),
    schematic: {voxels: [...], bounds: {...}},
    mass: 300,
    type: 'asteroid'
});
```

**States**:
- `flying` - Moving through space, physics applied
- `orbiting` - In stable orbit, tracking capture time
- `impacting` - Colliding with surface
- `captured` - Converted to moon

---

### 3. **DebrisPhysics.js**
All physics calculations separated from game logic.

**Gravity Zones**:
```
Surface:  distance <= planetRadius + 2m      (collision)
Fall:     planetRadius * 1.0 < d <= * 1.5    (accelerating)
Orbit:    planetRadius * 1.5 < d <= * 2.5    (stable orbits)
Escape:   distance > planetRadius * 2.5      (no gravity)
```

**Impact Types**:
- **Shatter** (v > 20 m/s): Creates crater + spawns fragments
- **Crater** (5 < v < 20 m/s): Creates small crater
- **Settle** (v < 5 m/s): Adds voxels to surface (no crater)

**Moon Capture**:
- Calculates orbital energy: ε = v²/2 - μ/r
- Negative energy = bound orbit (can capture)
- Checks periapsis > planetRadius + 10m (safe orbit)
- Captures after 1.5s continuous stable orbit

---

### 4. **DebrisManager.js**
Main coordinator system.

```javascript
const debrisManager = new DebrisManager(game);
debrisManager.setPlanet(planet);
debrisManager.setChunkSize(16);

// Spawn debris
debrisManager.spawnDebris({
    position: new THREE.Vector3(0, 300, 0),
    velocity: new THREE.Vector3(0, -25, 0),
    schematic: asteroidSchematic,
    type: 'comet'
});

// Update (call every frame)
debrisManager.update(deltaTime);

// Get stats
const stats = debrisManager.getStats();
console.log('Active debris:', stats.activeDebris);
console.log('Damaged chunks:', stats.damagedChunks);
```

---

## State Machine

```
[SPAWNED]
   ↓
[FLYING] ← Gravity, velocity, rotation
   ↓
   ├─→ Orbit Zone + Stable + 1.5s → [CAPTURED] (Moon)
   │
   └─→ Surface Collision → [IMPACTING]
                              ↓
                         Check Velocity
                              ↓
                  ┌───────────┼───────────┐
                  │           │           │
            v > 20 m/s   5-20 m/s    v < 5 m/s
                  │           │           │
              [SHATTER]   [CRATER]    [SETTLE]
                  │           │           │
           Crater +     Small       Add voxels
           Fragments    crater      to surface
```

---

## Integration Guide

### Step 1: Initialize System

```javascript
// In Game.js constructor
import { DebrisManager } from './world/debris/DebrisManager.js';

this.debrisManager = new DebrisManager(this);
```

### Step 2: Configure After Planet Load

```javascript
// After planet generation completes
this.debrisManager.setPlanet(this.mainPlanet);
this.debrisManager.setChunkSize(this.chunkSize);
```

### Step 3: Update Loop

```javascript
// In Game.js render() method, after orbital system
if (this.debrisManager) {
    this.debrisManager.update(deltaTime);
}
```

### Step 4: Chunk Loading Integration

```javascript
// Modify chunk loading to merge damage data
loadChunkMesh(chunkCoord) {
    const key = `${chunkCoord.cx},${chunkCoord.cy},${chunkCoord.cz}`;
    const baseChunk = this.planetChunks.get(key);

    // Get damage overlay
    const damageData = this.debrisManager.getDamageData(chunkCoord);

    // Merge base + damage
    const mergedVoxels = damageData.getMergedVoxelData(baseChunk.voxels);

    // Build mesh from merged data
    const mesh = this.buildMeshFromVoxels(mergedVoxels);
    this.loadedMeshes.set(key, mesh);
    this.scene.add(mesh);

    // Clear dirty flag
    damageData.isDirty = false;
}
```

### Step 5: UI Hooks

```javascript
// Spawn debris from UI
function spawnAsteroidField(count) {
    for (let i = 0; i < count; i++) {
        game.debrisManager.spawnDebris({
            position: randomOrbitPosition(),
            velocity: randomOrbitalVelocity(),
            schematic: generateAsteroidSchematic(),
            type: 'asteroid'
        });
    }
}

// Clear damage
function resetPlanetDamage() {
    game.debrisManager.clearAllDamage();
}

// Save damage state
function saveDamageState() {
    const data = game.debrisManager.exportDamageData();
    localStorage.setItem('planet_damage', JSON.stringify(data));
}

// Load damage state
function loadDamageState() {
    const data = JSON.parse(localStorage.getItem('planet_damage'));
    game.debrisManager.importDamageData(data);
}
```

---

## Usage Examples

### Comet Impact

```javascript
debrisManager.spawnDebris({
    position: new THREE.Vector3(0, 500, 0),
    velocity: new THREE.Vector3(5, -40, 2),
    angularVelocity: new THREE.Vector3(1, 2, 0.5),
    schematic: {
        voxels: [
            {x: 0, y: 0, z: 0, colorId: 7},  // Ice
            {x: 1, y: 0, z: 0, colorId: 7},
            {x: 0, y: 1, z: 0, colorId: 8}   // Rock
        ],
        bounds: {width: 2, height: 2, depth: 1}
    },
    type: 'comet'
});
```

### Asteroid Belt

```javascript
for (let i = 0; i < 50; i++) {
    const angle = (i / 50) * Math.PI * 2;
    const radius = 300;
    const position = new THREE.Vector3(
        Math.cos(angle) * radius,
        (Math.random() - 0.5) * 50,
        Math.sin(angle) * radius
    );

    const tangent = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle));
    const velocity = tangent.multiplyScalar(35);

    debrisManager.spawnDebris({
        position,
        velocity,
        schematic: randomAsteroidSchematic(),
        type: 'asteroid'
    });
}
```

### Moon Capture Setup

```javascript
// Spawn debris in orbit zone with correct velocity for capture
const orbitalRadius = 280; // Within orbit zone (225-375m)
const orbitalVelocity = Math.sqrt(G * planetMass / orbitalRadius);

debrisManager.spawnDebris({
    position: new THREE.Vector3(orbitalRadius, 0, 0),
    velocity: new THREE.Vector3(0, orbitalVelocity, 0),
    schematic: moonSchematic,
    type: 'moonlet'
});

// After 1.5s in stable orbit, will capture as moon
```

---

## Performance Considerations

1. **Spatial Hashing**: Only check collisions for debris near loaded chunks
2. **Dirty Flags**: Only rebuild chunk meshes when damage occurs
3. **Object Pooling**: Reuse DebrisEntity objects (max 100 active)
4. **LOD**: Distant debris uses simplified physics
5. **Batch Updates**: Multiple impacts per frame processed efficiently

---

## Coordinate Systems

**World Coordinates**: THREE.Vector3 in meters
- Origin at planet center
- Used for physics calculations

**Chunk Coordinates**: {cx, cy, cz}
- Integer indices of 16³ chunks
- `cx = floor(worldX / 16)`

**Local Coordinates**: {x, y, z}
- Position within chunk (0-15)
- `localX = worldX - (cx * 16)`

---

## Testing

Run the standalone test: `examples/debris_system_test.html`

Features:
- Spawn debris at different velocities
- Spawn asteroid fields
- Visualize gravity zones
- Export/import damage data
- Real-time stats display

---

## Future Enhancements

- [ ] Debris-debris mutual gravity
- [ ] Debris aggregation (sticking)
- [ ] Ring stability system
- [ ] Particle effects on impact
- [ ] Sound effects
- [ ] Save damage to .mvox format
- [ ] Multi-threaded crater calculation
- [ ] Debris LOD system

---

## API Reference

### DebrisManager

**Methods**:
- `setPlanet(planet)` - Set target planet
- `spawnDebris(config)` - Create new debris
- `update(deltaTime)` - Update all debris physics
- `clearAllDebris()` - Remove all active debris
- `clearAllDamage()` - Reset all planet damage
- `getStats()` - Get system statistics
- `exportDamageData()` - Serialize damage for save
- `importDamageData(data)` - Load saved damage

### ChunkDamageData

**Methods**:
- `addVoxel(x, y, z, colorId)` - Add settled voxel
- `removeVoxel(x, y, z)` - Create crater voxel
- `getMergedVoxelData(baseVoxels)` - Get merged Map
- `getMergedVoxelArray(baseVoxels)` - Get merged Array
- `clearDamage()` - Reset chunk to pristine
- `serialize()` - Export for save
- `static deserialize(data)` - Import from save

### DebrisEntity

**Properties**:
- `position` - THREE.Vector3
- `velocity` - THREE.Vector3
- `angularVelocity` - THREE.Vector3
- `state` - 'flying' | 'orbiting' | 'impacting' | 'captured'
- `mass` - Number (kg)
- `voxelCount` - Number

**Methods**:
- `updatePhysics(deltaTime, gravityAccel)` - Apply physics
- `transitionState(newState)` - Change state
- `dispose()` - Clean up resources

---

## License

Part of POLYMIR engine. All rights reserved.
